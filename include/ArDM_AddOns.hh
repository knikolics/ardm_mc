
#ifndef _PREPARATION_
#define _PREPARATION_ 1



#include "TMath.h"
#include "globals.hh"
#include "G4ThreeVector.hh"
#include "TVector2.h"
#include <vector>

using namespace std;


//be careful when using the following global variables in c++ code !
//-->why ?
//-->e.g.
//#define  AB  a*b
//in c++, you do :  double d = c/AB
//what you expect c++ to do is  : double d = c/(a*b)
//but what c++ actually does is : double d = c/a*b   <--- !!!

//--> so:
//either wrap the value after variable names in #define ... syntax with parentheses,
//especially when numeric operators involve

//or copy these variables to local varibales before using them
//e.g. : double AB_prime = AB; double d = c/AB_prime;


#define ARDM 1
//ARDM == 1  <--> ArDM geometry
//ARDM == 0  <--> sosuke's test setup
//ARDM == -1 <--> test object
//ARDM == 2 <--> test object, calculating fraction of photons getting trapped within the pmt WLS coating


#define USING_LIGHTMAP 0

#define DIGITIZATION 0

#define DARK_CURRENT_DIGITIZATION 0

#define WHITE_NOISE_DIGITIZATION 0




//GEANT4 seems, found out after many tests, to use left handed coordinate system --> go figure !!
//think of rotation in the right handed coord. system as usual, then add (handedness=) -1 before every rotation angle
//whenever you use G4RotationMatrix

#define HANDEDNESS -1

const string _HOME_ = "/cluster/home04/phys/khnguyen/";
#define ARDM_OUTPUT_TREE_DIR_DEFAULT ( _HOME_ + "/work/geneve/analysis/mc/ArDM/output/outputTree/")

#define CUBE666 0

#define NEUTRON_SHIELD 1


//simple neutron shield
#define TEST_NEUTRON_SHIELD 0

#define TURN_ON_SIDE_REFLECTOR 0
#define TURN_ON_SIDE_REFLECTOR_COATING 0
#define TURN_ON_CATHODE_GRID 1
#define TURN_ON_PROTECTION_GRID 1

#define SCALEFACTOR 1

#define VERBOSE 0

#define DEFAULTVALUE         -11111111

#define OMIT_PHOTON_TRACKING_IN_SCINT_PROCESS 0


#define GAS_TEST_2013_MARCH 0
#define GAS_TEST_2013_MARCH_SOURCE_HOLDER 0
#define GAS_TEST_2013_MARCH_ALPHA_SOURCE_SELECT_TRACK 0
#define GAS_TEST_2013_MARCH_SOURCE_COATING 0
#define GAS_TEST_2013_MARCH_ALPHA_SOURCE_QUICKRUN 1
#define GAS_TEST_2013_MARCH_ALPHA_SOURCE_CHOOSE_SHORT_TRACK_ONLY 1
 

#define GAS_TEST_2013_MARCH_GAMMA_SOURCE_FOR_SOSUKE 0

//shooting gamma in 4pi
//record the deposited energy separately for 2pi up and 2pi down
#define GAS_TEST_2013_MARCH_GAMMA_SOURCE_FOR_SOSUKE_2 0


//new geometry
#define WORLD_HALF_SIZE       4100   *mm  *SCALEFACTOR
#define TANK_TOTAL_HEIGHT     (2093. *mm*SCALEFACTOR)



//geometrical parameters for dewar

//// 2014 feb. 6th
//// try to simulate the stainless steel dewar more precisely
//// the dewar is a "union" of : --> see technical drawing of dewar !
//// 1. a cylinder and
//// 2. 3 spherical parts at the bottom
////    i.  one big arc at the (very) bottom of the dewar with radius R = 1010 mm --> here, called R1010_ARC
////    ii. 2 connecting arcs (one on each side in xz-view) with radius r = 101 mm, which connect the cylinder with the R1010-arc --> here, called R101_ARC
////
////
//// moreover, the wall of the dewar has the form of a sandwich of many alternating layers
//// from inside to outside it's
//// 1. 6 mm SS
//// 2. 5 mm LAr
//// 3. 3 mm SS
//// 4. 10 mm LAr
//// 5. 6 mm SS
//// 6. 25 mm vacuum
//// 7. 5 mm SS
////
////--> in order to simplify things :
//// 1. combine all the stainless steel (SS) layers to one single one. --> total thickness 20 mm
//// 2. add the LAr layers to the LAr volume inside the tank, which increases the volume of the LAr inside the tank by a negligible amount,
////    but still we can account for this by slightly increase the inner radius of the dewar from 500 mm to (500 + 5 + 10) mm
//// 3. ignore the vacuum layer.
////
//// this doesn't make any big difference for neutrons emitted from the dewar wall. since the LAr layers are too thin, 
//// and the vaccum layer doesn't have any effect on neutrons.


#define TANK_CYLINDER_INNER_RADIUS (500. *mm)
#define TANK_CYLINDER_THICKNESS    (20.  *mm)
#define TANK_CYLINDER_OUTER_RADIUS (TANK_CYLINDER_INNER_RADIUS + TANK_CYLINDER_THICKNESS)

#define TANK_BTM_PART_R1010_ARC_INNER_RADIUS (1010. *mm)
#define TANK_BTM_PART_R1010_ARC_OUTER_RADIUS (TANK_BTM_PART_R1010_ARC_INNER_RADIUS + TANK_CYLINDER_THICKNESS)

#define TANK_BTM_PART_R101_ARC_INNER_RADIUS (101. *mm)
#define TANK_BTM_PART_R101_ARC_OUTER_RADIUS (TANK_BTM_PART_R101_ARC_INNER_RADIUS + TANK_CYLINDER_THICKNESS)


#define TANK_BTM_PART_R1010_ARC_CHORD (2*(TANK_CYLINDER_INNER_RADIUS - TANK_BTM_PART_R101_ARC_INNER_RADIUS))
#define TANK_BTM_PART_R1010_ARC_OPENING_ANGLE (2* TMath::ASin(TANK_BTM_PART_R1010_ARC_CHORD /2 / (TANK_BTM_PART_R1010_ARC_INNER_RADIUS - TANK_BTM_PART_R101_ARC_INNER_RADIUS) ) / TMath::Pi() * 180 *deg)

#define TANK_BTM_PART_R101_ARC_OPENING_ANGLE (90*deg - TANK_BTM_PART_R1010_ARC_OPENING_ANGLE/2 )


#define DISTANCE_R1010_ARC_CENTER_TO_LOWER_EDGE_OF_TANK_CYLINDER ((TANK_BTM_PART_R1010_ARC_INNER_RADIUS - TANK_BTM_PART_R101_ARC_INNER_RADIUS)*cos(TANK_BTM_PART_R1010_ARC_OPENING_ANGLE/2) )

#define DISTANCE_LOWER_EDGE_OF_TANK_CYLINDER_TO_TANK_LOWERMOST_POINT (TANK_BTM_PART_R1010_ARC_INNER_RADIUS - DISTANCE_R1010_ARC_CENTER_TO_LOWER_EDGE_OF_TANK_CYLINDER)

#define TANK_CYLINDER_HALF_HEIGHT ((TANK_TOTAL_HEIGHT - DISTANCE_LOWER_EDGE_OF_TANK_CYLINDER_TO_TANK_LOWERMOST_POINT)/2)

#define TANK_BTM_PART_R101_ARC_HEIGHT (TANK_BTM_PART_R101_ARC_INNER_RADIUS * cos(TANK_BTM_PART_R1010_ARC_OPENING_ANGLE/2))






//// center of the cylindrical part of the tank is taken to be center of the tank
//// so when building the union of the cylindrical part and the btm spherical part of the tank
//// everything is calculated relative to the center of the tank (=center of the cylinder)
////
//// but in order to assure backward compatibility, the median point on the z-axis of the dewar,
//// which is at half height (= (cylinder's height + btm part's "height") / 2),
//// is taken to be the center of the detector !
//// so when placing the tank in "world" (world = physical volume),
//// pay attention to the position of the dewar relative to the center of "world" ! it's not (0,0,0) !
//// (center of world = center of the detector)




#define TANK_CYLINDER_POS_X 0
#define TANK_CYLINDER_POS_Y 0
#define TANK_CYLINDER_POS_Z (TANK_TOTAL_HEIGHT / 2 - TANK_CYLINDER_HALF_HEIGHT )


#define TANK_BTM_PART_R1010_X 0
#define TANK_BTM_PART_R1010_Y 0
#define TANK_BTM_PART_R1010_Z (TANK_BTM_PART_R1010_ARC_INNER_RADIUS - TANK_TOTAL_HEIGHT/2)
#define TANK_BTM_PART_R1010_Z_RELATIVE_TO_TANK_CYLINDER (TANK_BTM_PART_R1010_Z- TANK_CYLINDER_POS_Z)






// the connecting part r101_arc is a part of a torus,
// whose center is on the z-axis, and the center of the connecting part is the center of the torus !!
//--> see ArDM_DetectorConstruction::AddTank() for more !

#define DISTANCE_R1010_ARC_CENTER_TO_R101_ARC_CENTER (DISTANCE_R1010_ARC_CENTER_TO_LOWER_EDGE_OF_TANK_CYLINDER)

#define DISTANCE_TANK_LOWERMOST_POINT_TO_R101_ARC_CENTER (TANK_BTM_PART_R1010_ARC_INNER_RADIUS - DISTANCE_R1010_ARC_CENTER_TO_R101_ARC_CENTER)
#define DISTANCE_TANK_CYLINDER_CENTER_TO_R101_ARC_CENTER (TANK_CYLINDER_HALF_HEIGHT )
#define TANK_BTM_PART_R101_X 0
#define TANK_BTM_PART_R101_Y 0
//#define TANK_BTM_PART_R101_Z ( TANK_BTM_PART_R1010_Z - DISTANCE_R1010_ARC_CENTER_TO_R101_ARC_CENTER)
#define TANK_BTM_PART_R101_Z ( TANK_CYLINDER_POS_Z - DISTANCE_TANK_CYLINDER_CENTER_TO_R101_ARC_CENTER)
#define TANK_BTM_PART_R101_Z_RELATIVE_TO_TANK_CYLINDER (TANK_BTM_PART_R101_Z - TANK_CYLINDER_POS_Z)








//top flange

#define TOP_FLANGE_INNER_RADIUS  0.   *mm
#define TOP_FLANGE_OUTER_RADIUS  555. *mm
#define TOP_FLANGE_THICKNESS     40   *mm
#define TOP_FLANGE_HALF_HEIGHT   (TOP_FLANGE_THICKNESS/2)

//top flange = flange with some holes + stainless steel pillars
//thickness of the flange = 4 cm
//simplify the geometry by a simple stainless steel cylinder,
//instead of using 4cm as the cylinder height, reduce it a bit to account for the omitted pillars
//--> reduce by how much ??

#define TOP_FLANGE_COMPENSATION_FACTOR_FOR_OMITTED_PILLARS 0.9803485

#define TOP_FLANGE_HALF_HEIGHT_EFFECTIVE (TOP_FLANGE_HALF_HEIGHT * TOP_FLANGE_COMPENSATION_FACTOR_FOR_OMITTED_PILLARS) 

#define TOP_FLANGE_POS_X 0. *mm
#define TOP_FLANGE_POS_Y 0. *mm
#define TOP_FLANGE_POS_Z (TANK_CYLINDER_POS_Z + TANK_CYLINDER_HALF_HEIGHT + TOP_FLANGE_HALF_HEIGHT_EFFECTIVE)


















































































//from the relative distance of the detector components to the top flange
//calculate their coordinates in the coord. system where the origin is right in the middle of the detector.

#define DISTANCE_TOP_FLANGE_TOP_PMT_CENTER   249.2 *mm  *SCALEFACTOR

#define DISTANCE_UPPER_EDGE_FIELD_SHAPER_LIQUID_SURFACE 40*mm   *SCALEFACTOR


#define REFLECTOR_HALF_HEIGHT                538.5  *mm  *SCALEFACTOR

//#define DISTANCE_TOP_FLANGE_UPPER_EDGE_FIELD_SHAPER 542.5*mm   *SCALEFACTOR


//khoi's test
//#define DISTANCE_TOP_FLANGE_UPPER_EDGE_FIELD_SHAPER 445.5*mm   *SCALEFACTOR

//this is actually top flange lower edge <--> WLS upper edge
#define DISTANCE_TOP_FLANGE_UPPER_EDGE_FIELD_SHAPER 473. *mm   *SCALEFACTOR
//end khoi's test

//distance top flange <--> liquid surface is changable
//#define DISTANCE_TOP_FLANGE_LIQUID_SURFACE   433.5 *mm  *SCALEFACTOR
#define DISTANCE_TOP_FLANGE_LIQUID_SURFACE   (DISTANCE_TOP_FLANGE_UPPER_EDGE_FIELD_SHAPER-DISTANCE_UPPER_EDGE_FIELD_SHAPER_LIQUID_SURFACE)
#define LIQUID_SURFACE_POS_Z                 (TOP_FLANGE_POS_Z - TOP_FLANGE_HALF_HEIGHT_EFFECTIVE - DISTANCE_TOP_FLANGE_LIQUID_SURFACE)

#define DISTANCE_TOP_FLANGE_REFLECTOR_CENTER (DISTANCE_TOP_FLANGE_UPPER_EDGE_FIELD_SHAPER+REFLECTOR_HALF_HEIGHT)

#define DISTANCE_REFLECTOR_LOWER_EDGE_PROTECTION_GRID 133 *mm  *SCALEFACTOR  //<-- check it ! 
#define DISTANCE_PROTECTION_GRID_TIP_OF_BOTTOM_PMT     21 *mm  *SCALEFACTOR  //<-- check it !



#define GAR_COLUMN_HALF_HEIGHT DISTANCE_TOP_FLANGE_LIQUID_SURFACE/2
#define GAR_COLUMN_Z           (TOP_FLANGE_POS_Z - TOP_FLANGE_HALF_HEIGHT_EFFECTIVE - GAR_COLUMN_HALF_HEIGHT)

#define LAR_SURFACE_Z          LIQUID_SURFACE_POS_Z





//2014 feb. 11th 21h55
//simulate the LArCol in such a way that it fits the tank,
//which is composed of a cylinder and a "curved" bottom part

#define APPROX_LARCOL_TOTAL_HEIGHT (TANK_TOTAL_HEIGHT - DISTANCE_TOP_FLANGE_LIQUID_SURFACE)
#define APPROX_LARCOL_CYLINDER_HALFHEIGHT ((APPROX_LARCOL_TOTAL_HEIGHT - DISTANCE_LOWER_EDGE_OF_TANK_CYLINDER_TO_TANK_LOWERMOST_POINT)/2)
#define APPROX_LARCOL_CYLINDER_INNER_RADIUS (0. *mm)
#define APPROX_LARCOL_CYLINDER_OUTER_RADIUS (TANK_CYLINDER_INNER_RADIUS)
#define APPROX_LARCOL_CYLINDER_POS_X (0. *mm)
#define APPROX_LARCOL_CYLINDER_POS_Y (0. *mm)
#define APPROX_LARCOL_CYLINDER_POS_Z (-TANK_TOTAL_HEIGHT/2 + DISTANCE_LOWER_EDGE_OF_TANK_CYLINDER_TO_TANK_LOWERMOST_POINT + APPROX_LARCOL_CYLINDER_HALFHEIGHT)

#define APPROX_LARCOL_POS_Z APPROX_LARCOL_CYLINDER_POS_Z



//wavelength shifter
//for the time being, WLS mean absoprtion length is just an arbitrary number, here 10 micron. 
//if it's too small, GEANT4 might not like it, due to possible conflict with min step length
#define WLS_MEAN_ABSORPTION_LENGTH (.01 *mm)      
#define WLS_THICKNESS_100_PERCENT_CONVERSION_EFFICIENCY (0.2 *mm)


#define MAIN_REFLECTOR_CONVERSION_EFFICIENCY 10000*0.0001
//#define WLS_RINGSEC_THICKNESS     .001 *mm
#define WLS_RINGSEC_THICKNESS     getWLSThickness(MAIN_REFLECTOR_CONVERSION_EFFICIENCY)
#define WLS_RINGSEC_INNER_RADIUS  38.5 *cm *SCALEFACTOR 
#define WLS_RINGSEC_OUTER_RADIUS  (WLS_RINGSEC_INNER_RADIUS + WLS_RINGSEC_THICKNESS)
#define WLS_RINGSEC_HALF_HEIGHT   REFLECTOR_HALF_HEIGHT
#define WLS_RINGSEC_START_PHI     40.  *deg
#define WLS_RINGSEC_DELTA_PHI     280. *deg
#define WLS_RINGSEC_RADIUS        (WLS_RINGSEC_INNER_RADIUS + WLS_RINGSEC_OUTER_RADIUS)/2

#define WLS_RINGSEC_POS_X         0 *SCALEFACTOR 
#define WLS_RINGSEC_POS_Y         0 *SCALEFACTOR 
#define WLS_RINGSEC_POS_Z         (TOP_FLANGE_POS_Z - TOP_FLANGE_HALF_HEIGHT_EFFECTIVE - DISTANCE_TOP_FLANGE_REFLECTOR_CENTER)
#define WLS_RINGSEC_POS_Z_LARCOL  (WLS_RINGSEC_POS_Z - APPROX_LARCOL_POS_Z)



#define WLS_LINSEC_HALF_X         WLS_RINGSEC_RADIUS*sin(40.*deg)
#define WLS_LINSEC_HALF_Y         (WLS_RINGSEC_OUTER_RADIUS - WLS_RINGSEC_INNER_RADIUS)*cos(40.*deg)/2   
#define WLS_LINSEC_HALF_Z         WLS_RINGSEC_HALF_HEIGHT

//thickness of the linear sector = dimension in y-direction
#define WLS_LINSEC_HALF_THICKNESS WLS_LINSEC_HALF_Y   

#define WLS_LINSEC_POS_X          WLS_RINGSEC_RADIUS*cos(40.*deg)
#define WLS_LINSEC_POS_Y          0 *SCALEFACTOR
#define WLS_LINSEC_POS_Z          WLS_RINGSEC_POS_Z 
#define WLS_LINSEC_POS_Z_LARCOL   WLS_RINGSEC_POS_Z_LARCOL



//wavelength shifter support structure
#define WLS_SUPPORT_RINGSEC_INNER_RADIUS  WLS_RINGSEC_OUTER_RADIUS
#define WLS_SUPPORT_RINGSEC_THICKNESS     .3*mm
#define WLS_SUPPORT_RINGSEC_OUTER_RADIUS  (WLS_SUPPORT_RINGSEC_INNER_RADIUS + WLS_SUPPORT_RINGSEC_THICKNESS)
#define WLS_SUPPORT_RINGSEC_HALF_HEIGHT   WLS_RINGSEC_HALF_HEIGHT
#define WLS_SUPPORT_RINGSEC_START_PHI     WLS_RINGSEC_START_PHI
#define WLS_SUPPORT_RINGSEC_DELTA_PHI     WLS_RINGSEC_DELTA_PHI
#define WLS_SUPPORT_RINGSEC_RADIUS        (WLS_SUPPORT_RINGSEC_INNER_RADIUS + WLS_SUPPORT_RINGSEC_OUTER_RADIUS)/2

#define WLS_SUPPORT_RINGSEC_POS_X         WLS_RINGSEC_POS_X
#define WLS_SUPPORT_RINGSEC_POS_Y         WLS_RINGSEC_POS_Y
#define WLS_SUPPORT_RINGSEC_POS_Z         WLS_RINGSEC_POS_Z 
#define WLS_SUPPORT_RINGSEC_POS_Z_LARCOL  WLS_RINGSEC_POS_Z_LARCOL


#define WLS_SUPPORT_LINSEC_HALF_X         WLS_SUPPORT_RINGSEC_RADIUS*sin(40.*deg)
#define WLS_SUPPORT_LINSEC_HALF_Y         (WLS_SUPPORT_RINGSEC_OUTER_RADIUS - WLS_SUPPORT_RINGSEC_INNER_RADIUS)*cos(40.*deg)/2   
#define WLS_SUPPORT_LINSEC_HALF_Z         WLS_SUPPORT_RINGSEC_HALF_HEIGHT 


#define WLS_SUPPORT_LINSEC_POS_X          WLS_SUPPORT_RINGSEC_RADIUS*cos(40.*deg)
#define WLS_SUPPORT_LINSEC_POS_Y          WLS_LINSEC_POS_Y
#define WLS_SUPPORT_LINSEC_POS_Z          WLS_LINSEC_POS_Z
#define WLS_SUPPORT_LINSEC_POS_Z_LARCOL   WLS_LINSEC_POS_Z_LARCOL









#define EXTRACTION_GRID_GAP             1*cm




//// 2014 feb. 6th 
//// try to approximate the shape of the PMT more accurately
//// the PMT will be approximated by a "union" of geo. shapes
//// 1. a cylinder in the middle
//// 2. on top and bottom of the cylinder are 2 spherical parts with same curvature, each with opening angle ~ 50 degrees
//// 3. connecting to the btm (spherical) part is another cylinder (here called btm_tube), which connects the PMT with PMT base
//// 4. the center of the middle cylinder is taken to be the PMT center


#define APPROX_PMT_SPHERICAL_PART_INNER_RADIUS (131 *mm )
#define APPROX_PMT_THICKNESS    (2   *mm) //arbitrary for the time being
#define APPROX_PMT_SPHERICAL_PART_OUTER_RADIUS (APPROX_PMT_SPHERICAL_PART_INNER_RADIUS + APPROX_PMT_THICKNESS)
#define APPROX_PMT_SPHERICAL_PART_OPENING_ANGLE (2*50 *deg)
#define APPROX_PMT_ACTIVE_RANGE_OPENING_ANGLE (2*46.5 *deg)
#define APPROX_PMT_MIDDLE_CYLINDER_INNER_RADIUS (APPROX_PMT_SPHERICAL_PART_INNER_RADIUS*sin(APPROX_PMT_SPHERICAL_PART_OPENING_ANGLE/2))
#define APPROX_PMT_MIDDLE_CYLINDER_OUTER_RADIUS (APPROX_PMT_MIDDLE_CYLINDER_INNER_RADIUS + APPROX_PMT_THICKNESS)
#define APPROX_PMT_MIDDLE_CYLINDER_HALF_HEIGHT (27 *mm)


#define APPROX_PMT_SPHERICAL_PART_HEIGHT (APPROX_PMT_SPHERICAL_PART_OUTER_RADIUS - APPROX_PMT_SPHERICAL_PART_INNER_RADIUS*cos(APPROX_PMT_SPHERICAL_PART_OPENING_ANGLE/2))

#define APPROX_PMT_BTM_TUBE_INNER_RADIUS (42.25 *mm)
#define APPROX_PMT_BTM_TUBE_OUTER_RADIUS (APPROX_PMT_BTM_TUBE_INNER_RADIUS + APPROX_PMT_THICKNESS)
#define APPROX_PMT_BTM_TUBE_HALF_HEIGHT  (36    *mm)
#define APPROX_PMT_BTM_SPHERE_HOLE_OPENING_ANGLE (2*TMath::ASin(APPROX_PMT_BTM_TUBE_INNER_RADIUS / APPROX_PMT_SPHERICAL_PART_OUTER_RADIUS) / TMath::Pi() * 180 *deg )
//#define APPROX_PMT_BTM_SPHERE_HOLE_OPENING_ANGLE  <-- it's about 18.8 degrees


//PMT_CENTER = center of the cylinder in the middle, between 2 spherical parts
#define APPROX_PMT_DISTANCE_PMT_CENTER_TO_SPHERE_CENTER (fabs((APPROX_PMT_SPHERICAL_PART_INNER_RADIUS * cos(APPROX_PMT_SPHERICAL_PART_OPENING_ANGLE/2) - APPROX_PMT_MIDDLE_CYLINDER_HALF_HEIGHT ) ) )
#define APPROX_PMT_DISTANCE_PMT_CENTER_TO_TOP_SPHERE_CENTER APPROX_PMT_DISTANCE_PMT_CENTER_TO_SPHERE_CENTER
#define APPROX_PMT_DISTANCE_PMT_CENTER_TO_BTM_SPHERE_CENTER APPROX_PMT_DISTANCE_PMT_CENTER_TO_SPHERE_CENTER
#define APPROX_PMT_DISTANCE_PMT_CENTER_TO_BTM_TUBE_CENTER   (APPROX_PMT_SPHERICAL_PART_OUTER_RADIUS * cos(APPROX_PMT_BTM_SPHERE_HOLE_OPENING_ANGLE/2) - APPROX_PMT_DISTANCE_PMT_CENTER_TO_TOP_SPHERE_CENTER + APPROX_PMT_BTM_TUBE_HALF_HEIGHT )



//center of the pmt = center of the pmt middle cylinder !
#define DISTANCE_TOP_FLANGE_UPPER_EDGE_OF_TOP_PMT_TUBE 160. *mm

#define APPROX_TOP_PMT_Z (TOP_FLANGE_POS_Z - TOP_FLANGE_HALF_HEIGHT_EFFECTIVE - DISTANCE_TOP_FLANGE_UPPER_EDGE_OF_TOP_PMT_TUBE - APPROX_PMT_BTM_TUBE_HALF_HEIGHT - APPROX_PMT_DISTANCE_PMT_CENTER_TO_BTM_TUBE_CENTER)
#define APPROX_TOP_PMT_Z_GARCOL (APPROX_TOP_PMT_Z - GAR_COLUMN_Z)

#define APPROX_BTM_PMT_Z (WLS_RINGSEC_POS_Z - WLS_RINGSEC_HALF_HEIGHT - DISTANCE_REFLECTOR_LOWER_EDGE_PROTECTION_GRID - DISTANCE_PROTECTION_GRID_TIP_OF_BOTTOM_PMT - APPROX_PMT_SPHERICAL_PART_HEIGHT - APPROX_PMT_MIDDLE_CYLINDER_HALF_HEIGHT)

#define APPROX_BTM_PMT_Z_LARCOL (APPROX_BTM_PMT_Z - APPROX_LARCOL_POS_Z)



#define APPROX_TOP_PMT_CENTER_OF_TOP_SPHERE (APPROX_TOP_PMT_Z + APPROX_PMT_DISTANCE_PMT_CENTER_TO_TOP_SPHERE_CENTER)
#define APPROX_TOP_PMT_CENTER_OF_TOP_SPHERE_GARCOL (APPROX_TOP_PMT_CENTER_OF_TOP_SPHERE - GAR_COLUMN_Z)

#define APPROX_BTM_PMT_CENTER_OF_TOP_SPHERE (APPROX_BTM_PMT_Z - APPROX_PMT_DISTANCE_PMT_CENTER_TO_TOP_SPHERE_CENTER)
#define APPROX_BTM_PMT_CENTER_OF_TOP_SPHERE_LARCOL (APPROX_BTM_PMT_CENTER_OF_TOP_SPHERE - APPROX_LARCOL_POS_Z)











#define APPROX_PMT_BASE_RADIUS 30  *mm
#define APPROX_PMT_BASE_HALF_THICKNESS 1.6 *mm
#define APPROX_PMT_DISTANCE_LOWER_EDGE_OF_PMT_TUBE_TO_PMT_BASE_CENTER 5 *mm
#define APPROX_PMT_DISTANCE_PMT_CENTER_TO_PMT_BASE (APPROX_PMT_DISTANCE_PMT_CENTER_TO_BTM_TUBE_CENTER + APPROX_PMT_BTM_TUBE_HALF_HEIGHT + APPROX_PMT_DISTANCE_LOWER_EDGE_OF_PMT_TUBE_TO_PMT_BASE_CENTER)
#define APPROX_PMT_BASE_Z_TOP (APPROX_TOP_PMT_Z + APPROX_PMT_DISTANCE_PMT_CENTER_TO_PMT_BASE)
#define APPROX_PMT_BASE_Z_TOP_GARCOL (APPROX_PMT_BASE_Z_TOP - GAR_COLUMN_Z)

#define APPROX_PMT_BASE_Z_BTM (APPROX_BTM_PMT_Z - APPROX_PMT_DISTANCE_PMT_CENTER_TO_PMT_BASE)
#define APPROX_PMT_BASE_Z_BTM_LARCOL (APPROX_PMT_BASE_Z_BTM - APPROX_LARCOL_POS_Z)








#define APPROX_PMT_ELECTRODE_OUTER_RADIUS APPROX_PMT_BTM_TUBE_INNER_RADIUS
#define APPROX_PMT_ELECTRODE_HALF_HEIGHT  APPROX_PMT_BTM_TUBE_HALF_HEIGHT
//#define APPROX_PMT_ELECTRODE_HALF_HEIGHT  40 *mm
#define APPROX_PMT_ELECTRODE_DENSITY      (8.00 *g/cm3)  //stainless steel density
#define APPROX_PMT_ELECTRODE_WEIGHT       (197 *g)
#define APPROX_PMT_ELECTRODE_VOLUME       (APPROX_PMT_ELECTRODE_WEIGHT / APPROX_PMT_ELECTRODE_DENSITY) 
#define APPROX_PMT_ELECTRODE_INNER_RADIUS sqrt((TMath::Pi() * 2 * APPROX_PMT_ELECTRODE_HALF_HEIGHT * APPROX_PMT_ELECTRODE_OUTER_RADIUS*APPROX_PMT_ELECTRODE_OUTER_RADIUS - APPROX_PMT_ELECTRODE_VOLUME )/TMath::Pi() / 2/APPROX_PMT_ELECTRODE_HALF_HEIGHT) 


#define APPROX_PMT_ELECTRODE_Z_TOP (APPROX_TOP_PMT_Z + APPROX_PMT_DISTANCE_PMT_CENTER_TO_BTM_TUBE_CENTER )  
#define APPROX_PMT_ELECTRODE_Z_TOP_GARCOL (APPROX_PMT_ELECTRODE_Z_TOP - GAR_COLUMN_Z)

#define APPROX_PMT_ELECTRODE_Z_BTM (APPROX_BTM_PMT_Z - APPROX_PMT_DISTANCE_PMT_CENTER_TO_BTM_TUBE_CENTER)
#define APPROX_PMT_ELECTRODE_Z_BTM_LARCOL (APPROX_PMT_ELECTRODE_Z_BTM - APPROX_LARCOL_POS_Z)






// high voltage resistors
// see ArDM_DetectorConstruction::addHVr() for more infos
#define HV_RESISTOR_BAR_INNER_RADIUS 0. *mm
#define HV_RESISTOR_BAR_OUTER_RADIUS 4.1 *mm
#define HV_RESISTOR_BAR_HALF_HEIGHT  WLS_RINGSEC_HALF_HEIGHT


// linear sector of the WLS is perpendicular to the x-axis
#define DISTANCE_BETWEEN_HV_RESISTOR_BARS 100. *mm

#define HV_RESISTOR_BAR_1_POS_X (WLS_SUPPORT_LINSEC_POS_X + WLS_LINSEC_HALF_THICKNESS + HV_RESISTOR_BAR_OUTER_RADIUS)
#define HV_RESISTOR_BAR_1_POS_Y (WLS_LINSEC_POS_Y + DISTANCE_BETWEEN_HV_RESISTOR_BARS/2 )
#define HV_RESISTOR_BAR_1_POS_Z WLS_LINSEC_POS_Z
#define HV_RESISTOR_BAR_1_POS_Z_LARCOL (HV_RESISTOR_BAR_1_POS_Z - APPROX_LARCOL_POS_Z)

#define HV_RESISTOR_BAR_2_POS_X HV_RESISTOR_BAR_1_POS_X
#define HV_RESISTOR_BAR_2_POS_Y (HV_RESISTOR_BAR_1_POS_Y - DISTANCE_BETWEEN_HV_RESISTOR_BARS)
#define HV_RESISTOR_BAR_2_POS_Z HV_RESISTOR_BAR_1_POS_Z
#define HV_RESISTOR_BAR_2_POS_Z_LARCOL (HV_RESISTOR_BAR_2_POS_Z - APPROX_LARCOL_POS_Z)












#define BOTTOM_PMT_Z          APPROX_BTM_PMT_Z

#define BOTTOM_PMT_Z_LARCOL   (BOTTOM_PMT_Z - APPROX_LARCOL_POS_Z)                                //relative to LArColumn !

#define TOP_PMT_Z             APPROX_TOP_PMT_Z
#define TOP_PMT_Z_GARCOL      (TOP_PMT_Z - GAR_COLUMN_Z)                                   //relative to GArColumn !




#define TOP_PMT_COATING_CONVERSION_EFFICIENCY 10000*0.0001
#define TOP_PMT_COATING_THICKNESS     getWLSThickness(TOP_PMT_COATING_CONVERSION_EFFICIENCY)
#define TOP_PMT_COATING_INNER_RADIUS      APPROX_PMT_SPHERICAL_PART_OUTER_RADIUS
#define TOP_PMT_COATING_OUTER_RADIUS      (TOP_PMT_COATING_INNER_RADIUS + TOP_PMT_COATING_THICKNESS) 
#define TOP_PMT_COATING_OPENING_ANGLE APPROX_PMT_SPHERICAL_PART_OPENING_ANGLE
#define TOP_PMT_COATING_Z         (APPROX_TOP_PMT_Z + APPROX_PMT_DISTANCE_PMT_CENTER_TO_SPHERE_CENTER)
#define TOP_PMT_COATING_Z_GARCOL  (TOP_PMT_COATING_Z - GAR_COLUMN_Z)

#define BOTTOM_PMT_COATING_CONVERSION_EFFICIENCY 10000*0.0001
#define BOTTOM_PMT_COATING_THICKNESS  getWLSThickness(TOP_PMT_COATING_CONVERSION_EFFICIENCY)
#define BOTTOM_PMT_COATING_INNER_RADIUS      APPROX_PMT_SPHERICAL_PART_OUTER_RADIUS
#define BOTTOM_PMT_COATING_OUTER_RADIUS      (BOTTOM_PMT_COATING_INNER_RADIUS + BOTTOM_PMT_COATING_THICKNESS) 
#define BOTTOM_PMT_COATING_OPENING_ANGLE APPROX_PMT_SPHERICAL_PART_OPENING_ANGLE
#define BOTTOM_PMT_COATING_Z             (APPROX_BTM_PMT_Z - APPROX_PMT_DISTANCE_PMT_CENTER_TO_SPHERE_CENTER)
#define BOTTOM_PMT_COATING_Z_LARCOL      (BOTTOM_PMT_COATING_Z - APPROX_LARCOL_POS_Z)





// pmt conv. eff. ratios
#define TOP_CONV_EFF_RATIO_0 1
#define TOP_CONV_EFF_RATIO_1 1
#define TOP_CONV_EFF_RATIO_2 1
#define TOP_CONV_EFF_RATIO_3 1
#define TOP_CONV_EFF_RATIO_4 1
#define TOP_CONV_EFF_RATIO_5 1
#define TOP_CONV_EFF_RATIO_6 1
#define TOP_CONV_EFF_RATIO_7 1
#define TOP_CONV_EFF_RATIO_8 1
#define TOP_CONV_EFF_RATIO_9 1
#define TOP_CONV_EFF_RATIO_10 1
#define TOP_CONV_EFF_RATIO_11 1


#define TOP_CONV_EFF_0 10000*0.0001
#define TOP_CONV_EFF_1 (TOP_CONV_EFF_0*TOP_CONV_EFF_RATIO_1)
#define TOP_CONV_EFF_2 (TOP_CONV_EFF_0*TOP_CONV_EFF_RATIO_2)
#define TOP_CONV_EFF_3 (TOP_CONV_EFF_0*TOP_CONV_EFF_RATIO_3)
#define TOP_CONV_EFF_4 (TOP_CONV_EFF_0*TOP_CONV_EFF_RATIO_4)
#define TOP_CONV_EFF_5 (TOP_CONV_EFF_0*TOP_CONV_EFF_RATIO_5)
#define TOP_CONV_EFF_6 (TOP_CONV_EFF_0*TOP_CONV_EFF_RATIO_6)
#define TOP_CONV_EFF_7 (TOP_CONV_EFF_0*TOP_CONV_EFF_RATIO_7)
#define TOP_CONV_EFF_8 (TOP_CONV_EFF_0*TOP_CONV_EFF_RATIO_8)
#define TOP_CONV_EFF_9 (TOP_CONV_EFF_0*TOP_CONV_EFF_RATIO_9)
#define TOP_CONV_EFF_10 (TOP_CONV_EFF_0*TOP_CONV_EFF_RATIO_10)
#define TOP_CONV_EFF_11 (TOP_CONV_EFF_0*TOP_CONV_EFF_RATIO_11)







// // pmt conv. eff. ratios
// #define BOTTOM_CONV_EFF_RATIO_0 1
// #define BOTTOM_CONV_EFF_RATIO_1 1.01877
// #define BOTTOM_CONV_EFF_RATIO_2 0.991011
// #define BOTTOM_CONV_EFF_RATIO_3 1.06946
// #define BOTTOM_CONV_EFF_RATIO_4 0.900242
// #define BOTTOM_CONV_EFF_RATIO_5 1.06286

// //pmt6 in btm array = pmt18 --> crazy ! --> set the ratio to 1. for the time being
// #define BOTTOM_CONV_EFF_RATIO_6 1.
// #define BOTTOM_CONV_EFF_RATIO_7 1.03005
// #define BOTTOM_CONV_EFF_RATIO_8 0.767236
// #define BOTTOM_CONV_EFF_RATIO_9 0.927576
// #define BOTTOM_CONV_EFF_RATIO_10 0.821491
// #define BOTTOM_CONV_EFF_RATIO_11 0.746277




// pmt conv. eff. ratios
#define BOTTOM_CONV_EFF_RATIO_0 1
#define BOTTOM_CONV_EFF_RATIO_1 1
#define BOTTOM_CONV_EFF_RATIO_2 1
#define BOTTOM_CONV_EFF_RATIO_3 1
#define BOTTOM_CONV_EFF_RATIO_4 1
#define BOTTOM_CONV_EFF_RATIO_5 1

//pmt6 in btm array = pmt18 --> crazy ! --> set the ratio to 1. for the time being
#define BOTTOM_CONV_EFF_RATIO_6 1
#define BOTTOM_CONV_EFF_RATIO_7 1
#define BOTTOM_CONV_EFF_RATIO_8 1
#define BOTTOM_CONV_EFF_RATIO_9 1
#define BOTTOM_CONV_EFF_RATIO_10 1
#define BOTTOM_CONV_EFF_RATIO_11 1


#define BOTTOM_CONV_EFF_0 10000*0.0001
#define BOTTOM_CONV_EFF_1 (BOTTOM_CONV_EFF_0*BOTTOM_CONV_EFF_RATIO_1)
#define BOTTOM_CONV_EFF_2 (BOTTOM_CONV_EFF_0*BOTTOM_CONV_EFF_RATIO_2)
#define BOTTOM_CONV_EFF_3 (BOTTOM_CONV_EFF_0*BOTTOM_CONV_EFF_RATIO_3)
#define BOTTOM_CONV_EFF_4 (BOTTOM_CONV_EFF_0*BOTTOM_CONV_EFF_RATIO_4)
#define BOTTOM_CONV_EFF_5 (BOTTOM_CONV_EFF_0*BOTTOM_CONV_EFF_RATIO_5)
#define BOTTOM_CONV_EFF_6 (BOTTOM_CONV_EFF_0*BOTTOM_CONV_EFF_RATIO_6)
#define BOTTOM_CONV_EFF_7 (BOTTOM_CONV_EFF_0*BOTTOM_CONV_EFF_RATIO_7)
#define BOTTOM_CONV_EFF_8 (BOTTOM_CONV_EFF_0*BOTTOM_CONV_EFF_RATIO_8)
#define BOTTOM_CONV_EFF_9 (BOTTOM_CONV_EFF_0*BOTTOM_CONV_EFF_RATIO_9)
#define BOTTOM_CONV_EFF_10 (BOTTOM_CONV_EFF_0*BOTTOM_CONV_EFF_RATIO_10)
#define BOTTOM_CONV_EFF_11 (BOTTOM_CONV_EFF_0*BOTTOM_CONV_EFF_RATIO_11)





//**new** : implemented on dec. 18th 2013, 8:50 am
//--> *** modified on 2014 mar 19th , 10:10 am ***
//parameters for PMT cathode
//instead of setting the pmt glass layer as sensitive detector,
//now set the pmt cathode as sensitive detector !
//
//if we set the pmt glass layer as sensitive detector,
//we have to kill the photon immediately whenever it reaches the glass layer,
//this would mean that no total internal reflection on pmtGlassLayer -- pmtCoating surface is possible,
//whereas in reality, this can happen multiple times before the photon penetrates the glass layer to reach the pmt cathode.
//dunno if this (total internal reflection within the pmtCoating) makes a big difference, but still, 
//just to be careful !


//// mar. 19th 2014, 10:10 am
#define PMT_CATHODE_OUTER_RADIUS APPROX_PMT_SPHERICAL_PART_INNER_RADIUS
#define PMT_CATHODE_THICKNESS    0.001 * mm
#define PMT_CATHODE_INNER_RADIUS (PMT_CATHODE_OUTER_RADIUS - PMT_CATHODE_THICKNESS)
#define PMT_CATHODE_OPENING_ANGLE APPROX_PMT_ACTIVE_RANGE_OPENING_ANGLE
#define PMT_CATHODE_ACTIVE_RANGE (PMT_CATHODE_OPENING_ANGLE/2)  //46.5*deg
#define PMT_ACTIVE_RANGE_RADIUS  (APPROX_PMT_SPHERICAL_PART_OUTER_RADIUS*sin(PMT_CATHODE_ACTIVE_RANGE))
#define TOP_PMT_CATHODE_Z        TOP_PMT_COATING_Z
#define TOP_PMT_CATHODE_Z_GARCOL (TOP_PMT_CATHODE_Z - GAR_COLUMN_Z)

#define BTM_PMT_CATHODE_Z        BOTTOM_PMT_COATING_Z
#define BTM_PMT_CATHODE_Z_LARCOL (BTM_PMT_CATHODE_Z - APPROX_LARCOL_POS_Z)




//radius of active range in xy-plane
//in order to reduce run time --> assign numerical value to pmt_active_range_radius
//it's just the numerical result of the above definition for pmt_active_range_radius
//#define PMT_ACTIVE_RANGE_RADIUS  95.0240426*mm











//PMT support structure

#define PMT_SUPPORT_RADIUS               450 *mm *SCALEFACTOR
#define PMT_SUPPORT_HALF_HEIGHT          2.5 *mm *SCALEFACTOR

#define TOP_PMT_SUPPORT_POS_X            0   *mm *SCALEFACTOR
#define TOP_PMT_SUPPORT_POS_Y            0   *mm *SCALEFACTOR
//#define TOP_PMT_SUPPORT_POS_Z            (TOP_PMT_Z - PMT_OUTER_RADIUS*cos(PMT_ACTIVE_RANGE) + PMT_SUPPORT_HALF_HEIGHT)

//used along with approxPMT model
#define TOP_PMT_SUPPORT_POS_Z            (TOP_PMT_Z - APPROX_PMT_MIDDLE_CYLINDER_HALF_HEIGHT + PMT_SUPPORT_HALF_HEIGHT)
#define TOP_PMT_SUPPORT_POS_Z_GARCOL     (TOP_PMT_SUPPORT_POS_Z - GAR_COLUMN_Z)


#define BOTTOM_PMT_SUPPORT_POS_X         0   *mm *SCALEFACTOR
#define BOTTOM_PMT_SUPPORT_POS_Y         0   *mm *SCALEFACTOR
//#define BOTTOM_PMT_SUPPORT_POS_Z         (BOTTOM_PMT_Z + PMT_OUTER_RADIUS*cos(PMT_ACTIVE_RANGE) - PMT_SUPPORT_HALF_HEIGHT)

//used along with approxPMT model
#define BOTTOM_PMT_SUPPORT_POS_Z         (BOTTOM_PMT_Z + APPROX_PMT_MIDDLE_CYLINDER_HALF_HEIGHT - PMT_SUPPORT_HALF_HEIGHT)
#define BOTTOM_PMT_SUPPORT_POS_Z_LARCOL  (BOTTOM_PMT_SUPPORT_POS_Z - APPROX_LARCOL_POS_Z)


//PMT support coating

#define PMT_SUPPORT_COATING_RADIUS               PMT_SUPPORT_RADIUS


#define TOP_PMT_SUPPORT_CONVERSION_EFFICIENCY 10000*0.0001

//if the thickness is too thin, the program somehow doesn't work ! go figure !
//the minimum halfheight, at which the program/visualization still works, is 0.09 mm --> !!!???????
//#define PMT_SUPPORT_COATING_HALF_HEIGHT          0.001/2*mm 
#define TOP_PMT_SUPPORT_COATING_HALF_HEIGHT      (getWLSThickness(TOP_PMT_SUPPORT_CONVERSION_EFFICIENCY)/2.)

#define TOP_PMT_SUPPORT_COATING_POS_X            TOP_PMT_SUPPORT_POS_X
#define TOP_PMT_SUPPORT_COATING_POS_Y            TOP_PMT_SUPPORT_POS_Y
#define TOP_PMT_SUPPORT_COATING_POS_Z            (TOP_PMT_SUPPORT_POS_Z-PMT_SUPPORT_HALF_HEIGHT -TOP_PMT_SUPPORT_COATING_HALF_HEIGHT)
#define TOP_PMT_SUPPORT_COATING_POS_Z_GARCOL     (TOP_PMT_SUPPORT_COATING_POS_Z - GAR_COLUMN_Z)


#define BOTTOM_PMT_SUPPORT_CONVERSION_EFFICIENCY        TOP_PMT_SUPPORT_CONVERSION_EFFICIENCY
#define BOTTOM_PMT_SUPPORT_COATING_HALF_HEIGHT      (getWLSThickness(BOTTOM_PMT_SUPPORT_CONVERSION_EFFICIENCY)/2.)

#define BOTTOM_PMT_SUPPORT_COATING_POS_X         BOTTOM_PMT_SUPPORT_POS_X
#define BOTTOM_PMT_SUPPORT_COATING_POS_Y         BOTTOM_PMT_SUPPORT_POS_Y
#define BOTTOM_PMT_SUPPORT_COATING_POS_Z         (BOTTOM_PMT_SUPPORT_POS_Z+PMT_SUPPORT_HALF_HEIGHT+BOTTOM_PMT_SUPPORT_COATING_HALF_HEIGHT)
#define BOTTOM_PMT_SUPPORT_COATING_POS_Z_LARCOL  (BOTTOM_PMT_SUPPORT_COATING_POS_Z - APPROX_LARCOL_POS_Z)


















#define CATHODE_POS_X  0.*mm
#define CATHODE_POS_Y  0.*mm

#define CATHODE_POS_Z  (WLS_RINGSEC_POS_Z - WLS_RINGSEC_HALF_HEIGHT-1*mm)
////why (-1*mm) in cathode_z ???
////#define CATHODE_POS_Z  (WLS_RINGSEC_POS_Z - WLS_RINGSEC_HALF_HEIGHT-1*mm)
#define CATHODE_POS_Z_LARCOL (CATHODE_POS_Z - APPROX_LARCOL_POS_Z)


//#define CATHODE_PLATE_INNER_RADIUS     393.*mm
#define CATHODE_PLATE_INNER_RADIUS     WLS_SUPPORT_RINGSEC_OUTER_RADIUS
#define CATHODE_PLATE_OUTER_RADIUS     418.*mm *SCALEFACTOR
#define CATHODE_PLATE_HALF_THICKNESS   (13.4*mm/2)

#define CATHODE_WIRE_INNER_RADIUS     0*mm
#define CATHODE_WIRE_OUTER_RADIUS     .4*mm
#define CATHODE_WIRE_PITCH          (20*mm)









#define BOTTOM_PROTECTION_GRID_PLATE_INNER_RADIUS WLS_SUPPORT_RINGSEC_OUTER_RADIUS
//#define BOTTOM_PROTECTION_GRID_PLATE_OUTER_RADIUS 475*mm
#define BOTTOM_PROTECTION_GRID_PLATE_OUTER_RADIUS PMT_SUPPORT_RADIUS
#define BOTTOM_PROTECTION_GRID_PLATE_HALF_THICKNESS    2.5*mm

#define DISTANCE_LOWER_EDGE_CATHODE_PLATE_TO_UPPER_EDGE_BOTTOM_PROTECTION_GRID 120*mm*SCALEFACTOR

#define BOTTOM_PROTECTION_GRID_WIRE_INNER_RADIUS CATHODE_WIRE_INNER_RADIUS
#define BOTTOM_PROTECTION_GRID_WIRE_OUTER_RADIUS CATHODE_WIRE_OUTER_RADIUS
#define BOTTOM_PROTECTION_GRID_WIRE_PITCH        CATHODE_WIRE_PITCH




#define BOTTOM_PROTECTION_GRID_POS_X 0.
#define BOTTOM_PROTECTION_GRID_POS_Y 0.
#define BOTTOM_PROTECTION_GRID_POS_Z (CATHODE_POS_Z-CATHODE_PLATE_HALF_THICKNESS-DISTANCE_LOWER_EDGE_CATHODE_PLATE_TO_UPPER_EDGE_BOTTOM_PROTECTION_GRID-BOTTOM_PROTECTION_GRID_PLATE_HALF_THICKNESS)
#define BOTTOM_PROTECTION_GRID_POS_Z_LARCOL (BOTTOM_PROTECTION_GRID_POS_Z-APPROX_LARCOL_POS_Z)


















// //bottom side reflector
// //the part of the reflector w/o WLS layer
// //just right above the protection grid and right beneath the reflector with WLS layer

#define BOTTOM_SIDE_REFLECTOR_THICKNESS       .254 *mm
#define BOTTOM_SIDE_REFLECTOR_INNER_RADIUS    WLS_SUPPORT_RINGSEC_OUTER_RADIUS
#define BOTTOM_SIDE_REFLECTOR_OUTER_RADIUS    (BOTTOM_SIDE_REFLECTOR_INNER_RADIUS + BOTTOM_SIDE_REFLECTOR_THICKNESS)
#define BOTTOM_SIDE_REFLECTOR_HALF_HEIGHT     DISTANCE_REFLECTOR_LOWER_EDGE_PROTECTION_GRID/2  
#define BOTTOM_SIDE_REFLECTOR_START_PHI       0.   *deg
#define BOTTOM_SIDE_REFLECTOR_DELTA_PHI       360. *deg


#define BOTTOM_SIDE_REFLECTOR_POS_X         0 *SCALEFACTOR 
#define BOTTOM_SIDE_REFLECTOR_POS_Y         0 *SCALEFACTOR 
#define BOTTOM_SIDE_REFLECTOR_POS_Z         (WLS_RINGSEC_POS_Z - WLS_RINGSEC_HALF_HEIGHT - BOTTOM_SIDE_REFLECTOR_HALF_HEIGHT) //relative to tank !!
#define BOTTOM_SIDE_REFLECTOR_POS_Z_LARCOL  (BOTTOM_SIDE_REFLECTOR_POS_Z - APPROX_LARCOL_POS_Z)                //relative to LArColumn !






////new bottom side reflector
////for gas test in march/april 2013

//#define BOTTOM_SIDE_REFLECTOR_INNER_RADIUS_UPPER_EDGE  WLS_SUPPORT_RINGSEC_OUTER_RADIUS
//#define BOTTOM_SIDE_REFLECTOR_INNER_RADIUS_UPPER_EDGE  CATHODE_PLATE_OUTER_RADIUS
//#define BOTTOM_SIDE_REFLECTOR_INNER_RADIUS_UPPER_EDGE  WLS_SUPPORT_RINGSEC_OUTER_RADIUS
#define BOTTOM_SIDE_REFLECTOR_INNER_RADIUS_UPPER_EDGE  CATHODE_PLATE_OUTER_RADIUS
#define BOTTOM_SIDE_REFLECTOR_OUTER_RADIUS_UPPER_EDGE  (BOTTOM_SIDE_REFLECTOR_INNER_RADIUS_UPPER_EDGE+BOTTOM_SIDE_REFLECTOR_THICKNESS)
//#define BOTTOM_SIDE_REFLECTOR_INNER_RADIUS_LOWER_EDGE  PMT_SUPPORT_RADIUS
#define BOTTOM_SIDE_REFLECTOR_INNER_RADIUS_LOWER_EDGE  BOTTOM_PROTECTION_GRID_PLATE_OUTER_RADIUS
#define BOTTOM_SIDE_REFLECTOR_OUTER_RADIUS_LOWER_EDGE  (BOTTOM_SIDE_REFLECTOR_INNER_RADIUS_LOWER_EDGE+BOTTOM_SIDE_REFLECTOR_THICKNESS)

//#define BOTTOM_SIDE_REFLECTOR_HALF_HEIGHT_GASTEST      (((WLS_RINGSEC_POS_Z-WLS_RINGSEC_HALF_HEIGHT)-(BOTTOM_PMT_SUPPORT_POS_Z+PMT_SUPPORT_HALF_HEIGHT))/2)
//#define BOTTOM_SIDE_REFLECTOR_POS_Z_GASTEST (WLS_RINGSEC_POS_Z-WLS_RINGSEC_HALF_HEIGHT-BOTTOM_SIDE_REFLECTOR_HALF_HEIGHT_GASTEST)

#define BOTTOM_SIDE_REFLECTOR_HALF_HEIGHT_GASTEST      (((CATHODE_POS_Z-CATHODE_PLATE_HALF_THICKNESS)-(BOTTOM_PROTECTION_GRID_POS_Z+BOTTOM_PROTECTION_GRID_PLATE_HALF_THICKNESS))/2)

#define BOTTOM_SIDE_REFLECTOR_POS_Z_GASTEST (CATHODE_POS_Z-CATHODE_PLATE_HALF_THICKNESS-BOTTOM_SIDE_REFLECTOR_HALF_HEIGHT_GASTEST)

#define BOTTOM_SIDE_REFLECTOR_POS_Z_GASTEST_LARCOL (BOTTOM_SIDE_REFLECTOR_POS_Z_GASTEST-APPROX_LARCOL_POS_Z)






////
////2013, august 7th, modify slightly the shape of the bottom side reflector
////
////previous version : bottom side reflector = a cone spanned by the ring of cathode grid
////and the ring of the bottom PMT support
////
////--> problem : this cone cuts the ring of the bottom PMT protection grid
////
////--> now : replace this cone by :
////i.  a cone spanned by the ring of the cathode grid and the ring of the bottom PMT protection grid
////ii. AND a cylinder spanned by the ring of the bottom PMT protection grid and the ring of the bottom PMT support
////



#define BOTTOM_SIDE_REFLECTOR_CYNLIDRICAL_PART_INNER_RADIUS BOTTOM_PROTECTION_GRID_PLATE_OUTER_RADIUS
#define BOTTOM_SIDE_REFLECTOR_CYNLIDRICAL_PART_OUTER_RADIUS (BOTTOM_SIDE_REFLECTOR_CYNLIDRICAL_PART_INNER_RADIUS+BOTTOM_SIDE_REFLECTOR_THICKNESS)

#define BOTTOM_SIDE_REFLECTOR_CYNLIDRICAL_PART_HALF_HEIGHT (((BOTTOM_PROTECTION_GRID_POS_Z+BOTTOM_PROTECTION_GRID_PLATE_HALF_THICKNESS)-(BOTTOM_PMT_SUPPORT_POS_Z+PMT_SUPPORT_HALF_HEIGHT))/2)


#define BOTTOM_SIDE_REFLECTOR_CYNLIDRICAL_PART_POS_X 0.
#define BOTTOM_SIDE_REFLECTOR_CYNLIDRICAL_PART_POS_Y 0.
#define BOTTOM_SIDE_REFLECTOR_CYNLIDRICAL_PART_POS_Z ((BOTTOM_PROTECTION_GRID_POS_Z-BOTTOM_PROTECTION_GRID_PLATE_HALF_THICKNESS) - BOTTOM_SIDE_REFLECTOR_CYNLIDRICAL_PART_HALF_HEIGHT)

#define BOTTOM_SIDE_REFLECTOR_CYNLIDRICAL_PART_POS_Z_LARCOL (BOTTOM_SIDE_REFLECTOR_CYNLIDRICAL_PART_POS_Z-APPROX_LARCOL_POS_Z)





////top side reflector
////between the upper edge of the main reflector and the top PMTsupport
#define TOP_SIDE_REFLECTOR_THICKNESS                BOTTOM_SIDE_REFLECTOR_THICKNESS
#define TOP_SIDE_REFLECTOR_INNER_RADIUS_LOWER_EDGE  WLS_SUPPORT_RINGSEC_OUTER_RADIUS
#define TOP_SIDE_REFLECTOR_OUTER_RADIUS_LOWER_EDGE  (TOP_SIDE_REFLECTOR_INNER_RADIUS_LOWER_EDGE+BOTTOM_SIDE_REFLECTOR_THICKNESS)
#define TOP_SIDE_REFLECTOR_INNER_RADIUS_UPPER_EDGE  PMT_SUPPORT_RADIUS
#define TOP_SIDE_REFLECTOR_OUTER_RADIUS_UPPER_EDGE  (TOP_SIDE_REFLECTOR_INNER_RADIUS_UPPER_EDGE+TOP_SIDE_REFLECTOR_THICKNESS)
#define TOP_SIDE_REFLECTOR_HALF_HEIGHT        ((TOP_PMT_SUPPORT_POS_Z-PMT_SUPPORT_HALF_HEIGHT-(WLS_RINGSEC_POS_Z+WLS_RINGSEC_HALF_HEIGHT))/2)
#define TOP_SIDE_REFLECTOR_START_PHI 0.*deg
#define TOP_SIDE_REFLECTOR_DELTA_PHI 360.*deg


#define TOP_SIDE_REFLECTOR_POS_X 0.
#define TOP_SIDE_REFLECTOR_POS_Y 0.
#define TOP_SIDE_REFLECTOR_POS_Z (WLS_RINGSEC_POS_Z+WLS_RINGSEC_HALF_HEIGHT+TOP_SIDE_REFLECTOR_HALF_HEIGHT)
#define TOP_SIDE_REFLECTOR_POS_Z_GARCOL (TOP_SIDE_REFLECTOR_POS_Z-GAR_COLUMN_Z)







//////
//////see explanation in ArDM_DetectorConstruction::AddTopSideReflector()
//////

#define TOP_SIDE_REFLECTOR_HALF_HEIGHT_IN_GARCOL      ((TOP_PMT_SUPPORT_POS_Z - PMT_SUPPORT_HALF_HEIGHT - LIQUID_SURFACE_POS_Z)/2)
#define TOP_SIDE_REFLECTOR_HALF_HEIGHT_IN_LARCOL      (TOP_SIDE_REFLECTOR_HALF_HEIGHT-TOP_SIDE_REFLECTOR_HALF_HEIGHT_IN_GARCOL)
#define TOP_SIDE_REFLECTOR_COTAN_TILTING_ANGLE        ((PMT_SUPPORT_RADIUS-WLS_SUPPORT_RINGSEC_OUTER_RADIUS)/(2*TOP_SIDE_REFLECTOR_HALF_HEIGHT))

#define TOP_SIDE_REFLECTOR_INNER_RADIUS_UPPER_EDGE_IN_GARCOL PMT_SUPPORT_RADIUS
#define TOP_SIDE_REFLECTOR_OUTER_RADIUS_UPPER_EDGE_IN_GARCOL (TOP_SIDE_REFLECTOR_INNER_RADIUS_UPPER_EDGE_IN_GARCOL+TOP_SIDE_REFLECTOR_THICKNESS)
#define TOP_SIDE_REFLECTOR_INNER_RADIUS_LOWER_EDGE_IN_GARCOL (TOP_SIDE_REFLECTOR_INNER_RADIUS_UPPER_EDGE_IN_GARCOL-2*TOP_SIDE_REFLECTOR_HALF_HEIGHT_IN_GARCOL*TOP_SIDE_REFLECTOR_COTAN_TILTING_ANGLE)
#define TOP_SIDE_REFLECTOR_OUTER_RADIUS_LOWER_EDGE_IN_GARCOL (TOP_SIDE_REFLECTOR_INNER_RADIUS_LOWER_EDGE_IN_GARCOL+TOP_SIDE_REFLECTOR_THICKNESS)


#define TOP_SIDE_REFLECTOR_IN_GARCOL_POS_Z (TOP_PMT_SUPPORT_POS_Z-PMT_SUPPORT_HALF_HEIGHT-TOP_SIDE_REFLECTOR_HALF_HEIGHT_IN_GARCOL)
#define TOP_SIDE_REFLECTOR_IN_GARCOL_POS_Z_GARCOL (TOP_SIDE_REFLECTOR_IN_GARCOL_POS_Z-GAR_COLUMN_Z)




#define TOP_SIDE_REFLECTOR_INNER_RADIUS_UPPER_EDGE_IN_LARCOL TOP_SIDE_REFLECTOR_INNER_RADIUS_LOWER_EDGE_IN_GARCOL
#define TOP_SIDE_REFLECTOR_OUTER_RADIUS_UPPER_EDGE_IN_LARCOL (TOP_SIDE_REFLECTOR_INNER_RADIUS_UPPER_EDGE_IN_LARCOL+TOP_SIDE_REFLECTOR_THICKNESS)
//#define TOP_SIDE_REFLECTOR_INNER_RADIUS_LOWER_EDGE_IN_LARCOL WLS_SUPPORT_RINGSEC_OUTER_RADIUS
#define TOP_SIDE_REFLECTOR_INNER_RADIUS_LOWER_EDGE_IN_LARCOL WLS_SUPPORT_RINGSEC_INNER_RADIUS
#define TOP_SIDE_REFLECTOR_OUTER_RADIUS_LOWER_EDGE_IN_LARCOL (TOP_SIDE_REFLECTOR_INNER_RADIUS_LOWER_EDGE_IN_LARCOL+TOP_SIDE_REFLECTOR_THICKNESS)

#define TOP_SIDE_REFLECTOR_IN_LARCOL_POS_Z (TOP_SIDE_REFLECTOR_IN_GARCOL_POS_Z-TOP_SIDE_REFLECTOR_HALF_HEIGHT)
#define TOP_SIDE_REFLECTOR_IN_LARCOL_POS_Z_LARCOL (TOP_SIDE_REFLECTOR_IN_LARCOL_POS_Z-APPROX_LARCOL_POS_Z)

#define TOP_SIDE_REFLECTOR_IN_LARCOL_POS_Z_APPROX_LARCOL (TOP_SIDE_REFLECTOR_IN_LARCOL_POS_Z - APPROX_LARCOL_CYLINDER_POS_Z)














/////side reflector coating

#define BOTTOM_SIDE_REFLECTOR_COAT_THICKNESS 0.001*mm
#define BOTTOM_SIDE_REFLECTOR_COAT_OUTER_RADIUS_UPPER_EDGE BOTTOM_SIDE_REFLECTOR_INNER_RADIUS_UPPER_EDGE
#define BOTTOM_SIDE_REFLECTOR_COAT_INNER_RADIUS_UPPER_EDGE (BOTTOM_SIDE_REFLECTOR_COAT_OUTER_RADIUS_UPPER_EDGE-BOTTOM_SIDE_REFLECTOR_COAT_THICKNESS)

#define BOTTOM_SIDE_REFLECTOR_COAT_OUTER_RADIUS_LOWER_EDGE BOTTOM_SIDE_REFLECTOR_INNER_RADIUS_LOWER_EDGE
#define BOTTOM_SIDE_REFLECTOR_COAT_INNER_RADIUS_LOWER_EDGE (BOTTOM_SIDE_REFLECTOR_COAT_OUTER_RADIUS_LOWER_EDGE-BOTTOM_SIDE_REFLECTOR_COAT_THICKNESS)

#define BOTTOM_SIDE_REFLECTOR_COAT_HALF_HEIGHT_GASTEST BOTTOM_SIDE_REFLECTOR_HALF_HEIGHT_GASTEST


#define BOTTOM_SIDE_REFLECTOR_COAT_POS_X 0
#define BOTTOM_SIDE_REFLECTOR_COAT_POS_Y 0
#define BOTTOM_SIDE_REFLECTOR_COAT_POS_Z_GASTEST BOTTOM_SIDE_REFLECTOR_POS_Z_GASTEST
#define BOTTOM_SIDE_REFLECTOR_COAT_POS_Z_GASTEST_LARCOL (BOTTOM_SIDE_REFLECTOR_COAT_POS_Z_GASTEST-APPROX_LARCOL_POS_Z)


#define BOTTOM_SIDE_REFLECTOR_COAT_START_PHI    BOTTOM_SIDE_REFLECTOR_START_PHI   
#define BOTTOM_SIDE_REFLECTOR_COAT_DELTA_PHI    BOTTOM_SIDE_REFLECTOR_DELTA_PHI   






#define BOTTOM_SIDE_REFLECTOR_COAT_CYNLIDRICAL_PART_OUTER_RADIUS BOTTOM_SIDE_REFLECTOR_CYNLIDRICAL_PART_INNER_RADIUS
#define BOTTOM_SIDE_REFLECTOR_COAT_CYNLIDRICAL_PART_INNER_RADIUS (BOTTOM_SIDE_REFLECTOR_COAT_CYNLIDRICAL_PART_OUTER_RADIUS-BOTTOM_SIDE_REFLECTOR_COAT_THICKNESS)

#define BOTTOM_SIDE_REFLECTOR_COAT_CYNLIDRICAL_PART_HALF_HEIGHT BOTTOM_SIDE_REFLECTOR_CYNLIDRICAL_PART_HALF_HEIGHT


#define BOTTOM_SIDE_REFLECTOR_COAT_CYNLIDRICAL_PART_POS_X BOTTOM_SIDE_REFLECTOR_CYNLIDRICAL_PART_POS_X
#define BOTTOM_SIDE_REFLECTOR_COAT_CYNLIDRICAL_PART_POS_Y BOTTOM_SIDE_REFLECTOR_CYNLIDRICAL_PART_POS_Y
#define BOTTOM_SIDE_REFLECTOR_COAT_CYNLIDRICAL_PART_POS_Z BOTTOM_SIDE_REFLECTOR_CYNLIDRICAL_PART_POS_Z
#define BOTTOM_SIDE_REFLECTOR_COAT_CYNLIDRICAL_PART_POS_Z_LARCOL (BOTTOM_SIDE_REFLECTOR_COAT_CYNLIDRICAL_PART_POS_Z-APPROX_LARCOL_POS_Z)







#define TOP_SIDE_REFLECTOR_COAT_THICKNESS 0.001*mm

#define TOP_SIDE_REFLECTOR_COAT_OUTER_RADIUS_UPPER_EDGE_IN_GARCOL TOP_SIDE_REFLECTOR_INNER_RADIUS_UPPER_EDGE_IN_GARCOL
#define TOP_SIDE_REFLECTOR_COAT_INNER_RADIUS_UPPER_EDGE_IN_GARCOL (TOP_SIDE_REFLECTOR_COAT_OUTER_RADIUS_UPPER_EDGE_IN_GARCOL-TOP_SIDE_REFLECTOR_COAT_THICKNESS)

#define TOP_SIDE_REFLECTOR_COAT_OUTER_RADIUS_LOWER_EDGE_IN_GARCOL TOP_SIDE_REFLECTOR_INNER_RADIUS_LOWER_EDGE_IN_GARCOL
#define TOP_SIDE_REFLECTOR_COAT_INNER_RADIUS_LOWER_EDGE_IN_GARCOL (TOP_SIDE_REFLECTOR_COAT_OUTER_RADIUS_LOWER_EDGE_IN_GARCOL-TOP_SIDE_REFLECTOR_COAT_THICKNESS)

#define TOP_SIDE_REFLECTOR_COAT_HALF_HEIGHT_IN_GARCOL TOP_SIDE_REFLECTOR_HALF_HEIGHT_IN_GARCOL


#define TOP_SIDE_REFLECTOR_COAT_IN_GARCOL_POS_X 0
#define TOP_SIDE_REFLECTOR_COAT_IN_GARCOL_POS_Y 0
#define TOP_SIDE_REFLECTOR_COAT_IN_GARCOL_POS_Z TOP_SIDE_REFLECTOR_IN_GARCOL_POS_Z
#define TOP_SIDE_REFLECTOR_COAT_IN_GARCOL_POS_Z_GARCOL (TOP_SIDE_REFLECTOR_COAT_IN_GARCOL_POS_Z-GAR_COLUMN_Z)





#define TOP_SIDE_REFLECTOR_COAT_OUTER_RADIUS_UPPER_EDGE_IN_LARCOL TOP_SIDE_REFLECTOR_INNER_RADIUS_UPPER_EDGE_IN_LARCOL
#define TOP_SIDE_REFLECTOR_COAT_INNER_RADIUS_UPPER_EDGE_IN_LARCOL (TOP_SIDE_REFLECTOR_COAT_OUTER_RADIUS_UPPER_EDGE_IN_LARCOL-TOP_SIDE_REFLECTOR_COAT_THICKNESS)

#define TOP_SIDE_REFLECTOR_COAT_OUTER_RADIUS_LOWER_EDGE_IN_LARCOL TOP_SIDE_REFLECTOR_INNER_RADIUS_LOWER_EDGE_IN_LARCOL
#define TOP_SIDE_REFLECTOR_COAT_INNER_RADIUS_LOWER_EDGE_IN_LARCOL (TOP_SIDE_REFLECTOR_COAT_OUTER_RADIUS_LOWER_EDGE_IN_LARCOL-TOP_SIDE_REFLECTOR_COAT_THICKNESS)

#define TOP_SIDE_REFLECTOR_COAT_HALF_HEIGHT_IN_LARCOL TOP_SIDE_REFLECTOR_HALF_HEIGHT_IN_LARCOL


#define TOP_SIDE_REFLECTOR_COAT_IN_LARCOL_POS_X 0
#define TOP_SIDE_REFLECTOR_COAT_IN_LARCOL_POS_Y 0
#define TOP_SIDE_REFLECTOR_COAT_IN_LARCOL_POS_Z TOP_SIDE_REFLECTOR_IN_LARCOL_POS_Z
#define TOP_SIDE_REFLECTOR_COAT_IN_LARCOL_POS_Z_LARCOL (TOP_SIDE_REFLECTOR_COAT_IN_LARCOL_POS_Z-APPROX_LARCOL_POS_Z)





#define TOP_SIDE_REFLECTOR_COAT_START_PHI    TOP_SIDE_REFLECTOR_START_PHI   
#define TOP_SIDE_REFLECTOR_COAT_DELTA_PHI    TOP_SIDE_REFLECTOR_DELTA_PHI   





























#define PHOTON_ENERGY_THRESHOLD 6.*eV  //if photon energy is larger than this threshold --> it won't be detected !


//universal constants
#define PI                   TMath::Pi()
#define PIOVER3              PI/3

#define BOILING_POINT_ARGON  87.          *kelvin 
#define LAR_RHO              1390.        //kg/m3                      //LAr mass density
#define GAR_RHO              1.76         //kg/m3                      //at standard condition (273 K, 1 bar)

#define BOLTZMAN_K           TMath::K()   //joule /kelvin              //boltzmann constant
#define LAR_KT               2.18e-9      //m2/newton                  //LAr isothermal compressibility
#define PLANCK_H             TMath::H()   *kg*m2/s
#define LIGHTSPEED           TMath::C()   *m/s

#define KE_LAR               1./6/PI*BOLTZMAN_K*BOILING_POINT_ARGON*LAR_KT*LAR_RHO*LAR_RHO
//KE_LAR is used in ArDM_DetectorConstruction::RayleighAttenuationLength(..)




//polycarbonate's parameters
#define POLYCARBONATE_DENSITY  1.20 *g/cm3  //<-- wikipedia : rho = 1.20 -- 1.22 g/cm3
#define POLYCARBONATE_REFINDEX 1.584        //<-- wikipedia : refIndex = 1.584 -- 1.586; for the time being: const refIndex


//polyethylene's parameters
#define POLYETHYLENE_DENSITY   0.940 *g/cm3



#define TIMESAMPLE           4 *ns 
#define TIMESAMPLEBOTTOM     TIMESAMPLE
#define TIMESAMPLETOP        TIMESAMPLE
#define NTIMESAMPLE          2048
#define NTIMESAMPLEBOTTOM    NTIMESAMPLE
#define NTIMESAMPLETOP       NTIMESAMPLE


#define NPMT 12
#define NTOPPMT    NPMT
#define NBOTTOMPMT NPMT



#define PARTICLE_ENERGY  (9.686 *eV)


#define PRIMARY_PHOTON_MEAN_E     PARTICLE_ENERGY
#define PRIMARY_PHOTON_SIGMA_E    (.5 *eV)           //for the time being, test with arbitrary sigma !


#define SECONDARY_PHOTON_MEAN_E   (2.95 *eV)         // <--> ~ 420 nm <-- check this number !
#define SECONDARY_PHOTON_SIGMA_E  (.5 *eV)           //for the time being, test with arbitrary sigma !


//numerical values taken from SVN code:
//for scintillation process

//drift field
#define ELECTRIC_FIELD_STRENGTH 0*volt/cm

#define DIELECTRIC_CONSTANT_GAR 1.
#define DIELECTRIC_CONSTANT_LAR 1.4


//extraction field
#define EXTRACTION_FIELD_STRENGTH 4*kilovolt/cm


#define W_GAMMA_LAR              (19.1 *eV)  //average energy needed to produce an Ar-excited state with emission of a photon
#define W0_LAR                   (23.6 *eV)  //average energy needed to create an e-ion pair.


//w-values for GAr may depend on the pressure !
//for alpha particles with Ekin > 1 MeV
#define W_GAMMA_GAR 1000*eV
#define W_ION_GAR                (26.4 *eV)

// #define W_GAMMA                  19.1 *eV  
// #define W0                       23.6 *eV  

#define W_GAMMA                  W_GAMMA_LAR
#define W0                       W0_LAR


//#define CX                       1856 *cm/kilovolt // <-- "1856" is taken from WARP proposal, used in box model
//#define CX                       (1856 *kilovolt/cm) // <-- kilovolt !!????
//#define CX                       (1856 *volt/cm) // <-- "1856" is taken from WARP proposal, used in box model
#define CX                       (840*volt/cm) //<-- value taken from "recombination of e-ion pairs in LAr and LX"
//J.Thomas and D.I.Imel, phys. rev. A36, vol. 2, july 15, 1987


//for nuclear quenching according to Lindhard
#define A_LINDHARD           .1406  
#define ALPHA_LINDHARD       .228



//bi-excitonic quenching in neutron-like events
#define Q_BIEXCITONIC        .6




//for calculating quenching factor for electron-like evetns
#define QUENCHING_ELECTRON_LIKE_K  (0.0486 *kilovolt/MeV)
#define QUENCHING_ELECTRON_LIKE_A  0.8





//attenuation length due to impurities
//lambda = alpha*E/rho                  <-- in cm
//alpha = (0.15 +- 0.03)cm2 = const     <-- cm2
//E     = field strength                <-- kV/cm
//rho   = impurity concentration        <-- in ppm (oxygen equivalent)
#define ATTENUATION_LENGTH_IMPURITY_ALPHA           .15 
#define IMPURITY_CONCENTRATION_OXYGEN_EQUIVALENT    0.0000001  //for the time being, set it to very low ! 
#define ATTENUATION_LENGTH_IMPURITY (ATTENUATION_LENGTH_IMPURITY_ALPHA*ELECTRIC_FIELD_STRENGTH/(kilovolt/cm)/IMPURITY_CONCENTRATION_OXYGEN_EQUIVALENT)*cm






//drift velocity of electrons in LAr
//from paper : "drift velocity of free electrons in LAr"
//W.Walkowiak, nucl. instr. meth. A 449, 288-294, 2000
//
//E : field strength
//T : temperature
//
//v_drift(E,T) = (P1*(T-T0) + 1)*(P3*E*ln(1+P4/E)+P5*E^P6)+P2*(T-T0)
//
//T0 = 90.371 K = const
//P1 = -0.01481 +- 0.00095 K^-1
//P2 = -0.0075  +- 0.0028  K^-1
//P3 =  0.141   +- 0.023   (kV/cm)^-1
//P4 = 12.4     +- 2.7     kV/cm
//P5 =  1.627   +- 0.078   (kV/cm)^-P6 
//P6 =  0.3147  +- 0.021   
//
//[v_drift] = mm/us
//[E]       = kV/cm
//[T]       = K
//


#define ELECTRON_V_DRIFT_IN_LAR_T0  (90.371*kelvin)
#define ELECTRON_V_DRIFT_IN_LAR_P1  (-0.01481/kelvin)
#define ELECTRON_V_DRIFT_IN_LAR_P2  (-0.0075 /kelvin)
#define ELECTRON_V_DRIFT_IN_LAR_P3  (0.141*cm/kilovolt)
#define ELECTRON_V_DRIFT_IN_LAR_P4  (12.4*kilovolt/cm)
#define ELECTRON_V_DRIFT_IN_LAR_P6  0.317
#define ELECTRON_V_DRIFT_IN_LAR_P5  (1.627*pow(kilovolt/cm,-ELECTRON_V_DRIFT_IN_LAR_P6))

#define ELECTRON_V_DRIFT_IN_LAR     ((ELECTRON_V_DRIFT_IN_LAR_P1*(BOILING_POINT_ARGON-ELECTRON_V_DRIFT_IN_LAR_T0)+1)*(ELECTRON_V_DRIFT_IN_LAR_P3*(ELECTRIC_FIELD_STRENGTH)*log(1+ELECTRON_V_DRIFT_IN_LAR_P4/(ELECTRIC_FIELD_STRENGTH))+ELECTRON_V_DRIFT_IN_LAR_P5*pow(ELECTRIC_FIELD_STRENGTH,ELECTRON_V_DRIFT_IN_LAR_P6))+ELECTRON_V_DRIFT_IN_LAR_P2*(BOILING_POINT_ARGON-ELECTRON_V_DRIFT_IN_LAR_T0))




//diffusion of electron cloud
//from chapter 6.3 in W.R.Leo
//"techniques for nuclear and particle physics experiments"
//
//<-- applied for gas
//<-- applicable for liquid ??
//
//1D : sigma = sqrt(2*D*t)
//D = diffusion coefficient
//t = drift time
//
//3D : sigma = sqrt(6*D*t)
//
#define ELECTRON_CLOUD_DIFFUSION_COEFFICIENT (4.8*cm2/s) //<-- taken from Lilian Kaufmann's thesis






//ratio fast/(fast+slow)
#define SCINTILLATION_YIELD_RATIO  .75 //for neutron

#define ELECTRONEXCITATIONRATIO    .23
#define NEUTRONEXCITATIONRATIO     .75

#define PMT_QUANTUM_EFFICIENCY     1.
//#define PMT_QUANTUM_EFFICIENCY     .18


#define REFLECTIVITY_OF_TANK               0.  *.01
#define REFLECTIVITY_OF_TOP_LID            0.  *.01
#define REFLECTIVITY_OF_BOTTOM_LID         0.  *.01

//no absorption on liquid surface
#define REFLECTIVITY_OF_LAR_SURFACE        100 *.01

#define REFLECTIVITY_OF_REFLECTOR 9845*0.0001
#define REFLECTIVITY_OF_TOP_SIDE_REFLECTOR 10000*0.0001
#define REFLECTIVITY_OF_BOTTOM_SIDE_REFLECTOR REFLECTIVITY_OF_TOP_SIDE_REFLECTOR
#define REFLECTIVITY_OF_PMT_SUPPORT 10000*.01
#define REFLECTIVITY_OF_PMT_SUPPORT_TOP 10000*0.0001
#define REFLECTIVITY_OF_PMT_SUPPORT_BOTTOM REFLECTIVITY_OF_PMT_SUPPORT_TOP
#define REFLECTIVITY_OF_PMT_SUPPORT_COAT   10000*.01

//the "inner" side of PMT
#define REFLECTIVITY_OF_PMT_BACKSIDE       0.  *.01

//the outer side facing WLS layer of PMT
//optical photons will be killed whenever they arrive at PMTs' surfaces
//so the reflectivity of the optical surface between the PMT and PMTCoat is not important
#define REFLECTIVITY_OF_PMT_FRONTSIDE      100 *.01

//no absorption on the surface between LAr/GAr and PMTCoat
#define REFLECTIVITY_OF_PMTCOAT            100 *.01



#define REFLECTIVITY_OF_PROTECTION_GRID 5000*0.0001
#define REFLECTIVITY_OF_CATHODE_GRID 5000*0.0001



//reflectivity of an optical surface composes of the following 4 components, whose weights should add up to 1,
//1. specular spike <-- probably (very) small contribution
//2. specular lobe
//3. back scatter   <-- photon is scattered back (by 180 degrees) exactly in the direction where it comes from <-- unprobably
//4. lambertian
//
//--> 4 parameters, 1 constraint (sum = 1), 2 a priori assumption (specular spike ~ 0, back scatter ~ 0) 
//--> 1 parameter remains <-- either specular lobe or lambertian


#define MAIN_REFLECTOR_SPECULAR_SPIKE 0.
#define MAIN_REFLECTOR_SPECULAR_LOBE 0*0.0001
#define MAIN_REFLECTOR_BACK_SCATTER  0.
#define MAIN_REFLECTOR_LAMBERTIAN    (1. - MAIN_REFLECTOR_BACK_SCATTER - MAIN_REFLECTOR_SPECULAR_LOBE - MAIN_REFLECTOR_SPECULAR_SPIKE)


#define TOP_SIDE_REFLECTOR_SPECULAR_SPIKE 0.
#define TOP_SIDE_REFLECTOR_SPECULAR_LOBE 0*0.0001
#define TOP_SIDE_REFLECTOR_BACK_SCATTER  0.
#define TOP_SIDE_REFLECTOR_LAMBERTIAN    (1. - TOP_SIDE_REFLECTOR_SPECULAR_LOBE - TOP_SIDE_REFLECTOR_BACK_SCATTER - TOP_SIDE_REFLECTOR_SPECULAR_SPIKE)



#define BOTTOM_SIDE_REFLECTOR_SPECULAR_SPIKE TOP_SIDE_REFLECTOR_SPECULAR_SPIKE
#define BOTTOM_SIDE_REFLECTOR_SPECULAR_LOBE TOP_SIDE_REFLECTOR_SPECULAR_LOBE
#define BOTTOM_SIDE_REFLECTOR_BACK_SCATTER  TOP_SIDE_REFLECTOR_BACK_SCATTER
#define BOTTOM_SIDE_REFLECTOR_LAMBERTIAN    (1. - BOTTOM_SIDE_REFLECTOR_SPECULAR_LOBE - BOTTOM_SIDE_REFLECTOR_BACK_SCATTER - BOTTOM_SIDE_REFLECTOR_SPECULAR_SPIKE)


#define TOP_PMT_SUPPORT_SPECULAR_SPIKE 0.
#define TOP_PMT_SUPPORT_SPECULAR_LOBE 0*0.0001
#define TOP_PMT_SUPPORT_BACK_SCATTER  0.
#define TOP_PMT_SUPPORT_LAMBERTIAN    (1. - TOP_PMT_SUPPORT_SPECULAR_LOBE -TOP_PMT_SUPPORT_BACK_SCATTER - TOP_PMT_SUPPORT_SPECULAR_SPIKE)



#define BOTTOM_PMT_SUPPORT_SPECULAR_SPIKE  TOP_PMT_SUPPORT_SPECULAR_SPIKE
#define BOTTOM_PMT_SUPPORT_SPECULAR_LOBE  TOP_PMT_SUPPORT_SPECULAR_LOBE
#define BOTTOM_PMT_SUPPORT_BACK_SCATTER   TOP_PMT_SUPPORT_BACK_SCATTER
#define BOTTOM_PMT_SUPPORT_LAMBERTIAN     (1. - BOTTOM_PMT_SUPPORT_SPECULAR_LOBE -BOTTOM_PMT_SUPPORT_BACK_SCATTER - BOTTOM_PMT_SUPPORT_SPECULAR_SPIKE)




#define MAIN_REFLECTOR_SIGMA_ALPHA 0*0.0001
#define TOP_SIDE_REFLECTOR_SIGMA_ALPHA 0*0.0001
#define BOTTOM_SIDE_REFLECTOR_SIGMA_ALPHA TOP_SIDE_REFLECTOR_SIGMA_ALPHA
#define TOP_PMT_SUPPORT_REFLECTOR_SIGMA_ALPHA 0*0.0001
#define BOTTOM_PMT_SUPPORT_REFLECTOR_SIGMA_ALPHA TOP_PMT_SUPPORT_REFLECTOR_SIGMA_ALPHA









//scintillation process in LAr

#define LAR_SCINTILLATIONYIELD           40e3/MeV
#define LAR_RESOLUTIONSCALE              1.
#define LAR_FASTTIMECONSTANT             7.0 *ns
#define LAR_SLOWTIMECONSTANT             1.5 *microsecond
#define LAR_FASTSCINTILLATIONRISETIME    2.0 *ns   //for the time being : arbitrary value !!
#define LAR_SLOWSCINTILLATIONRISETIME    2.0 *ns   //for the time being : arbitrary value !!
#define LAR_YIELDRATIO                   0.23      //place holder
#define LAR_YIELDRATIO_ELECTRON          0.23                   
#define LAR_EXCITATIONRATIO_ELECTRON     0.23
#define LAR_EXCITATIONRATIO_NEUTRON      0.75


//scintillation process in GAr

//for GAr, values of the parameters are for the time being only place holders !!
//check the correct values !!!
#define GAR_SCINTILLATIONYIELD           40e3/MeV  //not needed for the time being
#define GAR_RESOLUTIONSCALE              1.
#define GAR_FASTTIMECONSTANT 7*ns
#define GAR_SLOWTIMECONSTANT 3500*ns
#define GAR_FASTSCINTILLATIONRISETIME    2.0 *ns   //for the time being : arbitrary value !!
#define GAR_SLOWSCINTILLATIONRISETIME    2.0 *ns   //for the time being : arbitrary value !!
#define GAR_YIELDRATIO                   0.23      //fast/slow component -- place holder
#define GAR_YIELDRATIO_ELECTRON          0.23                   
#define GAR_YIELDRATIO_ALPHA 0.4
#define GAR_EXCITATIONRATIO_ELECTRON     0.23
#define GAR_EXCITATIONRATIO_NEUTRON      0.75








//perlite isolator
//the perlite volume surrounds the dewar / topflange, 
//so we have to cut the cylindrical volume with appropriate objects to give the correct shape to the perlite volume

#define PERLITE_COLUMN_INNER_RADIUS 0 *mm
#define PERLITE_COLUMN_OUTER_RADIUS (718. *mm)
#define PERLITE_COLUMN_HALF_HEIGHT  (376. *mm)

#define DISTANCE_PERLITE_COLUMN_UPPER_EDGE_TO_TOP_FLANGE_LOWER_EDGE (279.5 *mm)
#define PERLITE_COLUMN_UPPER_EDGE_POS_Z (TOP_FLANGE_POS_Z - TOP_FLANGE_HALF_HEIGHT + DISTANCE_PERLITE_COLUMN_UPPER_EDGE_TO_TOP_FLANGE_LOWER_EDGE)

#define PERLITE_COLUMN_POS_X 0 *mm
#define PERLITE_COLUMN_POS_Y 0 *mm
#define PERLITE_COLUMN_POS_Z (PERLITE_COLUMN_UPPER_EDGE_POS_Z - PERLITE_COLUMN_HALF_HEIGHT)


















//select physics processes
#define RAYLEIGHSCATTERINGPROCESS 1
#define BOUNDARYPROCESS 1
#define WAVELENGTHSHIFTINGPROCESS 1
#define SCINTILLATIONPROCESS 0




///////////////////////////////////////////////////////////////
/////////////////////////TEST//////////////////////////////////
///////////////////////////////////////////////////////////////


#define TESTDIRX   0//sqrt(1.5)/3
#define TESTDIRY   1//sqrt(7.5)/3
#define TESTDIRZ   0


//normal ! standard branches : total number of photons detected by all PMT in array, time sample, ...
#define TEST_BRANCH0 0

//add:
//total number of detected photons by 1 PMT in 1 event
//total number of photons detected by 1 PMT in 1 event in 1 timesample 
#define TEST_BRANCH00 0

//optical photons: number of reflections, scattering, WLS, total reflection
#define TEST_BRANCH1 0

//add:number of scint. photons in slow/fast component, ...
#define TEST_BRANCH2 0

//add: scintillation emission time
#define TEST_BRANCH3 0


//ionisation + bremsstrahlung process : Ekin, Edep, range, dEdx, ....
#define TEST_BRANCH4 0

//neutron : elastic scattering, Ekin, dEdx, scatt. length, timestep between 2 scatterings
#define TEST_BRANCH5 0

//neutron : counting number of elastic scatterings (in fiducial volume)
#define TEST_BRANCH6 0

//neutron : inelastic scattering, spectrum of transfer energy, spectrum of emitted gammas
#define TEST_BRANCH7 0

//gamma : photo-electric
#define TEST_BRANCH8 0

//test usage of commands in GEANT4 macros  
#define TEST_BRANCH9 0


//test: interaction of optical photon in makrolon
#define TEST_BRANCH10 0


//position at which the optical photons are killed
#define TEST_BRANCH11 0


//Sosuke's test setup
#define TEST_BRANCH12 0


//sosuke's test setup 
//counting the number of alpha particles making it through the collimator
#define TEST_BRANCH12A 0

//testing source container
//test the spectrum of alpha's after passing through the container wall
#define TEST_BRANCH12B 0


//test: interaction of neutron in makrolon
#define TEST_BRANCH13 0


//neutron shield in LAr
#define TEST_BRANCH14 0


#define TEST_BRANCH14A 0
//neutron shield in LAr
//for difference between TEST_BRANCH14 and TEST_BRANCH14A
//see the explanation in ArDM_DetectorConstruction::addNeutronShield_test()
//TEST_BRANCH14 <--> ArDM_DetectorConstruction::addNeutronShield()
//TEST_BRANCH14A <--> ArDM_DetectorConstruction::addNeutronShield_test()



//neutron interaction in LAr
//recoil energy --> see ArADM_Analysis.hh for more info
#define TEST_BRANCH15 0


//neutron shield in air
//Ekin of neutrons right before and after passing the shield
#define TEST_BRANCH16 0


//neutron : elastic + inelastic + nCapture all together
//check energy transfer
#define TEST_BRANCH17 0


//neutron shield in LAr
//neutrons are emitted with some certain initial Ekin
//and pass through the shield immediately right after being emitted
//after passing through the shield
//count the fraction of neutrons (normalized to the number of neutrons initially emitted)
//which can induce elastic scattering with Erecoil larger than some threshold
#define TEST_BRANCH18 0



//neutron interaction : elastic, inelastic scattering, neutron capture
//mean Edep, mean steplength when turning all processes on
#define TEST_BRANCH19 0




//light yield vs external Efield in LAr
//charge      vs external Efield in LAr
#define TEST_BRANCH20 0


//alpha source with source holder
#define TEST_BRANCH21 0




// test neutron shield
#define TEST_BRANCH22 0


//calculate fraction of photons trapped within the PMT coating
#define TEST_BRANCH23 0



//neutron background simulation
//see branch24 in ArDM_Analysis.hh for more informations
//--> also see preparation.cc , keyword branch24, for more explanation about changing the size of the simulated PMT.
#define TEST_BRANCH24 1




//testing Rn222 (actually emitting 5.6 MeV alpha) in GAr
#define TEST_BRANCH25 0












//e.g. used in scintillation process
//if you just want to count the number of photons produced in scint. process
//and don't want to track (thousands) of optical photons
#define QUICKRUN 0


#define TEST_OBJECT_THICKNESS 80*mm

#define TEST_OBJECT_REFLECTIVITY 70*.01


//energy threshold of nuclear recoil
#define ENERGY_THRESHOLD_NUCLEAR_RECOIL 10*keV

#define STORE_TRAJECTORY  0

#define RANDOMPOS2D 0









//test: neutron shield


#define NEUTRON_SHIELD_THICKNESS 5*cm
#define NEUTRON_SHIELD_DISTANCE_TO_REFLECTOR 1*cm
#define NEUTRON_SHIELD_INNER_RADIUS       (WLS_SUPPORT_RINGSEC_OUTER_RADIUS + NEUTRON_SHIELD_DISTANCE_TO_REFLECTOR)
#define NEUTRON_SHIELD_OUTER_RADIUS       (NEUTRON_SHIELD_INNER_RADIUS+NEUTRON_SHIELD_THICKNESS)
#define NEUTRON_SHIELD_HALF_HEIGHT        (WLS_SUPPORT_RINGSEC_HALF_HEIGHT+BOTTOM_SIDE_REFLECTOR_HALF_HEIGHT)


#define NEUTRON_SHIELD_POS_X              WLS_SUPPORT_RINGSEC_POS_X
#define NEUTRON_SHIELD_POS_Y              WLS_SUPPORT_RINGSEC_POS_Y
#define NEUTRON_SHIELD_POS_Z              (WLS_SUPPORT_RINGSEC_POS_Z - BOTTOM_SIDE_REFLECTOR_HALF_HEIGHT)
//#define NEUTRON_SHIELD_POS_Z_LAR          (NEUTRON_SHIELD_POS_Z - APPROX_LARCOL_POS_Z)
#define NEUTRON_SHIELD_POS_Z_LAR          (NEUTRON_SHIELD_POS_Z - APPROX_LARCOL_CYLINDER_POS_Z)




//end test


//parameter for source

#define SOURCE_RADIUS 8.5*mm
#define SOURCE_HALF_THICKNESS 0.0001*cm

#define SOURCE_POS_X 0.0*cm
#define SOURCE_POS_Y 0.0*cm
#define SOURCE_POS_Z -71*mm
#define SOURCE_POS_Z_REL_TO_LARCOL (SOURCE_POS_Z-APPROX_LARCOL_POS_Z)



//parameters for source holder

//original source holder's dimensions
#define SOURCE_HOLDER_HALF_X 15*mm 
#define SOURCE_HOLDER_HALF_Y 25*mm

// x-y flipped
//#define SOURCE_HOLDER_HALF_X 25*mm 
//#define SOURCE_HOLDER_HALF_Y 15*mm



//make source holder a square
//#define SOURCE_HOLDER_HALF_X 25*mm 
//#define SOURCE_HOLDER_HALF_Y 25*mm

#define SOURCE_HOLDER_HALF_Z 10*mm

#define SOURCE_HOLDER_HOLE_RADIUS       SOURCE_RADIUS
#define SOURCE_HOLDER_HOLE_HALF_HEIGHT  (SOURCE_HOLDER_HALF_Z/2)

#define SOURCE_HOLDER_POS_X SOURCE_POS_X
#define SOURCE_HOLDER_POS_Y SOURCE_POS_Y
#define SOURCE_HOLDER_POS_Z (SOURCE_POS_Z+SOURCE_HALF_THICKNESS)
#define SOURCE_HOLDER_POS_Z_REL_TO_LARCOL (SOURCE_HOLDER_POS_Z-APPROX_LARCOL_POS_Z)

#define SOURCE_HOLDER_HOLE_POS_RELATIVE_TO_SOURCE_HOLDER_CENTER_X 0.0*mm
#define SOURCE_HOLDER_HOLE_POS_RELATIVE_TO_SOURCE_HOLDER_CENTER_Y 0.0*mm
#define SOURCE_HOLDER_HOLE_POS_RELATIVE_TO_SOURCE_HOLDER_CENTER_Z -SOURCE_HOLDER_HOLE_HALF_HEIGHT


#define SOURCE_COATING_RADIUS       SOURCE_HOLDER_HOLE_RADIUS
#define SOURCE_COATING_THICKNESS    0.006*mm
#define SOURCE_COATING_HALF_HEIGHT  SOURCE_COATING_THICKNESS/2


#define SOURCE_COATING_POS_X 0.0*mm
#define SOURCE_COATING_POS_Y 0.0*mm
//#define SOURCE_COATING_POS_Z (SOURCE_HOLDER_POS_Z-1.*0.001*cm - SOURCE_COATING_HALF_HEIGHT)
#define SOURCE_COATING_POS_Z (SOURCE_HOLDER_POS_Z - SOURCE_COATING_HALF_HEIGHT)
#define SOURCE_COATING_POS_Z_REL_TO_LARCOL (SOURCE_COATING_POS_Z-APPROX_LARCOL_POS_Z)


























///////////////////////////////////////////////////////
///////////////////////////////////////////////////////
//////////////////6 x 6 x 6 CUBE///////////////////////
///////////////////////////////////////////////////////
///////////////////////////////////////////////////////






#define CUBE666_HALF_X  3*m 
#define CUBE666_HALF_Y  3*m
#define CUBE666_LAR_AND_GAR_VOL_HALF_HEIGHT 3*m

#define CUBE666_DISTANCE_CATHODE_GRID_TO_PMT_CENTER  1*m
#define CUBE666_DISTANCE_TANK_BOTTOM_TO_PMT_CENTER   1*m


#define CUBE666_HALF_Z  (CUBE666_LAR_AND_GAR_VOL_HALF_HEIGHT+(CUBE666_DISTANCE_CATHODE_GRID_TO_PMT_CENTER+CUBE666_DISTANCE_TANK_BOTTOM_TO_PMT_CENTER)/2)


#define CUBE666_HALF_THICKNESS 5*mm  //arbitrary number




#define CUBE666_WALL_HALF_X (CUBE666_HALF_X + 2*CUBE666_HALF_THICKNESS)
#define CUBE666_WALL_HALF_Y (CUBE666_HALF_Y + 2*CUBE666_HALF_THICKNESS)
#define CUBE666_WALL_HALF_Z (CUBE666_HALF_Z + 2*CUBE666_HALF_THICKNESS)



#define CUBE666_GARCOL_HALF_X CUBE666_HALF_X
#define CUBE666_GARCOL_HALF_Y CUBE666_HALF_Y
#define CUBE666_GARCOL_HALF_HEIGHT  1*cm

#define CUBE666_GARCOL_POS_X 0
#define CUBE666_GARCOL_POS_Y 0
#define CUBE666_GARCOL_POS_Z (CUBE666_HALF_Z-CUBE666_GARCOL_HALF_HEIGHT)


#define CUBE666_LARCOL_HALF_X CUBE666_HALF_X
#define CUBE666_LARCOL_HALF_Y CUBE666_HALF_Y
#define CUBE666_LARCOL_HALF_HEIGHT  (CUBE666_HALF_Z-CUBE666_GARCOL_HALF_HEIGHT)

#define CUBE666_LARCOL_POS_X 0
#define CUBE666_LARCOL_POS_Y 0
#define CUBE666_LARCOL_POS_Z (-(CUBE666_HALF_Z-CUBE666_LARCOL_HALF_HEIGHT))


#define CUBE666_CATHODE_GRID 1

#define CUBE666_CATHODE_WIRE_INNER_RADIUS  0*mm
#define CUBE666_CATHODE_WIRE_OUTER_RADIUS  2.5*mm
#define CUBE666_CATHODE_WIRE_PITCH_X  (5*cm)
#define CUBE666_CATHODE_WIRE_PITCH_Y  (5*cm)
#define CUBE666_CATHODE_WIRE_POS_Z    (-(CUBE666_HALF_Z-CUBE666_DISTANCE_CATHODE_GRID_TO_PMT_CENTER-CUBE666_DISTANCE_TANK_BOTTOM_TO_PMT_CENTER))


//#define CUBE666_DISTANCE_PMT_CENTER_TO_TANK_WALL_X .5*m
//#define CUBE666_DISTANCE_PMT_CENTER_TO_TANK_WALL_Y .5*m

// //pmt pitch center-to-center
// #define CUBE666_PMT_PITCH_X (1*m)
// #define CUBE666_PMT_PITCH_Y (1*m)

#define CUBE666_DISTANCE_PMT_CENTER_TO_TANK_WALL_X .25*m
#define CUBE666_DISTANCE_PMT_CENTER_TO_TANK_WALL_Y .25*m

//pmt pitch center-to-center
#define CUBE666_PMT_PITCH_X (.5*m)
#define CUBE666_PMT_PITCH_Y (.5*m)



#define CUBE666_NPMT_X ((int)(2*(CUBE666_HALF_X-CUBE666_DISTANCE_PMT_CENTER_TO_TANK_WALL_X)/CUBE666_PMT_PITCH_X)+1)
#define CUBE666_NPMT_Y ((int)(2*(CUBE666_HALF_Y-CUBE666_DISTANCE_PMT_CENTER_TO_TANK_WALL_Y)/CUBE666_PMT_PITCH_Y)+1)


#if CUBE666

#ifdef NPMT
#undef NPMT
#define NPMT 144 //36//(CUBE666_NPMT_X*CUBE666_NPMT_Y)
#else
#define NPMT 144 //36//(CUBE666_NPMT_X*CUBE666_NPMT_Y)

#endif

#endif //CUBE




#define CUBE666_PMT_POS_Z (-(CUBE666_HALF_Z-CUBE666_DISTANCE_TANK_BOTTOM_TO_PMT_CENTER))
#define CUBE666_PMT_POS_Z_LAR (CUBE666_PMT_POS_Z-CUBE666_LARCOL_POS_Z)







#define CUBE666_REFLECTIVITY_LAR_TANK 100. *0.01
#define CUBE666_REFLECTIVITY_GAR_TANK 100. *0.01


#define CUBE666_REFLECTIVITY_OF_LAR_SURFACE 100. *0.01
#define CUBE666_REFLECTIVITY_OF_PMTCOAT     100. *0.01



#define CUBE666_REFLECTIVITY_OF_PMT_BACKSIDE       0.  *.01


///////////////////////////////////////////////////////
///////////////////////////////////////////////////////
///////////////END OF 6 x 6 x 6 CUBE///////////////////
///////////////////////////////////////////////////////
///////////////////////////////////////////////////////
























































//some common methods

// extern "C++" const double TOP_CONV_EFF[NTOPPMT];
// extern "C++" const double BOTTOM_CONV_EFF[NBOTTOMPMT];


const double TOP_CONV_EFF[NTOPPMT] = {TOP_CONV_EFF_0,
				      TOP_CONV_EFF_1,
				      TOP_CONV_EFF_2,
				      TOP_CONV_EFF_3,
				      TOP_CONV_EFF_4,
				      TOP_CONV_EFF_5,
				      TOP_CONV_EFF_6,
				      TOP_CONV_EFF_7,
				      TOP_CONV_EFF_8,
				      TOP_CONV_EFF_9,
				      TOP_CONV_EFF_10,
				      TOP_CONV_EFF_11
                                      };



const double BOTTOM_CONV_EFF[NBOTTOMPMT] = {BOTTOM_CONV_EFF_0,
					    BOTTOM_CONV_EFF_1,
					    BOTTOM_CONV_EFF_2,
					    BOTTOM_CONV_EFF_3,
					    BOTTOM_CONV_EFF_4,
					    BOTTOM_CONV_EFF_5,
					    BOTTOM_CONV_EFF_6,
					    BOTTOM_CONV_EFF_7,
					    BOTTOM_CONV_EFF_8,
					    BOTTOM_CONV_EFF_9,
					    BOTTOM_CONV_EFF_10,
					    BOTTOM_CONV_EFF_11
                                           };


extern "C++" vector<TVector2>      setPMTVector2D();
extern "C++" vector<G4ThreeVector> setPMTVector(const char* top_or_bottom="bottom");
extern "C++" G4ThreeVector         sphericalDistribution(const char* direction="");
extern "C++" G4ThreeVector         randomPos2D(G4double radius,G4double z);
extern "C++" G4ThreeVector         polarizationVec(G4ThreeVector perpTo); //generate a vector perpendicular to perpTo
extern "C++" void                  plotTest();
extern "C++" G4int                 isInFiducialVolume(G4ThreeVector pos);
extern "C++" G4int                 isInShieldedVolume(G4ThreeVector pos);
extern "C++" vector<G4ThreeVector> setGridWireVector(const char* xyAxis,vector<double>& wireHalfLength,
						     double plateInnerR, double wirePitch, double wireOuterR);

extern "C++" double                getWLSThickness(double convEff);


extern "C++" vector<vector<string> > readTextFile_string(string filename,char delimiter='\t');
extern "C++" vector<vector<double> > readTextFile_float(string filename,char delimiter='\t');

extern "C++" G4int                   canUseLightMap(G4ThreeVector pos);

////cube 6 x 6 x 6
extern "C++" vector<TVector2>      setPMTVector2D_cube666();
extern "C++" vector<G4ThreeVector> setPMTVector_cube666();
extern "C++" vector<G4ThreeVector> setCathodeWireVector_cube666(const char* xyAxis);

////end cube 6 x 6 x 6





//g++ requires template header in the same file as implementation !!
//--> define the template inside .hh file !
template<class T> void copy1DArray(T* sourceArray,T* targetArray, int nentries){

  for(int i=0;i<nentries;i++) targetArray[i] = sourceArray[i];
  return;
}


template<class T> void copy1DArray(vector<T> sourceArray,T* targetArray, int nentries){

  int n1 = sourceArray.size();
  nentries = (n1>nentries)?nentries:n1;
  for(int i=0;i<nentries;i++) targetArray[i] = sourceArray[i];
  return;
}


template<class T> void copy2DArray(T** sourceArray,T** targetArray, int nentries1, int nentries2){

  for(int i=0;i<nentries1;i++) copy1DArray<T>(sourceArray[i],targetArray[i],nentries2);
  return;
}



template<class T> void reset1DArray(T* array, int nentries, T defaultValue){
  for(int i=0;i<nentries;i++) array[i] = defaultValue;
  return;
}



template<class T> void reset2DArray(T** array, int nentries1, int nentries2, T defaultValue){
  for(int i1=0;i1<nentries1;i1++) 
    for(int i2=0;i2<nentries2;i2++) 
      array[i1][i2] = defaultValue;
  return;
}






#endif //_PREPARATION_
